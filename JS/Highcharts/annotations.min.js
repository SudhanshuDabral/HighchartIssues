var template = "<div id='divSlope' class='keep_only_btn_main_Annotation' ><div class='keep_only_btn_parent_DCA'><div class='col-md-12'><span id='spnSlope'></span></div></div></div>", editBoxHTML = ['<div class="hc-editbox modal-content">', '<div class="hc-editbox-content">', '<div class="hc-editbox-item">', '<select class="hc-fontsize form-control">', '<option value="12">12px</option>', '<option value="15">15px</option>', '<option value="16">16px</option>', "</select>", "</div>", '<div class="hc-editbox-item">', '<button type="button" class="hc-bold btn btn-default">B</button>', '<div class="hc-editbox-item">', '<button type="button" class="hc-italic btn btn-default">I</button>', "</div>", '<div class="hc-editbox-item">', '<input type="text" class="hc-font-color color" value="#ffffff"/>', "</div>", '<div class="hc-editbox-item">', '<button type="button" class="hc-accept btn btn-primary">Apply</button>', "</div>", "</div>", "</div>"].join(""), isSlopeActive = !1, rotateCursor = "url(images/rotation_cursor.png), pointer", selectCursor = "url(images/selection_cursor.png), pointer", WellMBEPlotArray = []; !function (t) { function o(t) { var o, n; return n = { xAxis: 0, yAxis: 0, shape: { params: { stroke: "#000000", fill: "rgba(0,0,0,0)", "stroke-width": 4 } } }, o = { circle: { params: { x: 0, y: 0 } } }, o[t] && (n.shape = m(n.shape, o[t])), n } function n() { var t = [], o = ["circle", "line", "square", "text"], n = ["circle", "path", "rect", null], e = [{ r: 0, fill: "rgba(255,0,0,0.4)", stroke: "black" }, { d: ["M", 0, 0, "L", 10, 10], fill: "rgba(255,0,0,0.4)", stroke: "black", cursor: selectCursor }, { width: 10, height: 10, fill: "rgba(255,0,0,0.4)", stroke: "black" }], a = [V.getRadius, V.getPath, V.getRect, V.getText], i = [V.getRadiusAndUpdate, V.getPathAndUpdate, V.getRectAndUpdate, V.showInput]; return A(o, function (o, s) { t.push({ annotationEvents: { step: a[s], stop: i[s] }, annotation: { anchorX: "left", anchorY: "top", xAxis: 0, yAxis: 0, shape: { type: n[s], params: e[s] } }, symbol: { shape: o, size: 12, style: { "stroke-width": 2, stroke: "black", fill: "red", zIndex: 121 } }, style: { fill: "black", stroke: "blue", strokeWidth: 2 }, size: 12, states: { selected: { fill: "#9BD" }, hover: { fill: "#9BD" } } }) }), { enabledButtons: !0, buttons: t, buttonsOffsets: [0, 0] } } function e(t) { return "[object Array]" === Object.prototype.toString.call(t) } function a(t) { return "number" == typeof t } function i(t) { return t !== f && null !== t } function s(t, o, n, e, a) { for (var i = t.length, s = 0, l = []; i > s;)"number" == typeof t[s] && "number" == typeof t[s + 1] ? (l[s] = o.toPixels(t[s]) - e, l[s + 1] = n.toPixels(t[s + 1]) - a, s += 2) : (l[s] = t[s], s += 1); return l } function l(t, o, n) { var e = t.renderer.g("annotations-group-" + o); return e.attr({ zIndex: 7 }), e.add(), e.clip(n), e } function r(t, o) { var n = { x: o.left, y: o.top, width: o.width, height: o.height }; return t.renderer.clipRect(n) } function p(o) { function n(n) { var a = o.container.getBoundingClientRect(), i = n.clientX - a.left, s = n.clientY - a.top; if (o.isInsidePlot(i - o.plotLeft, s - o.plotTop) && !o.annotations.allowZoom) { var l = o.xAxis[0], r = o.yAxis[0], p = o.annotations.selected, d = m(o.annotations.options.buttons[p].annotation, { xValue: l.toValue(i), yValue: r.toValue(s), allowDragX: !0, allowDragY: !0, events: { dblclick: function () { this.destroy() }, mousedown: function () { this.renderRotateAndTranslatePoints() } } }); o.addAnnotation(d), o.drawAnnotation = o.annotations.allItems[o.annotations.allItems.length - 1], t.addEvent(document, "mousemove", e) } } function e(t) { var n = o.annotations.selected; o.annotations.options.buttons[n].annotationEvents.step.call(o.drawAnnotation, t) } function a(n) { if (t.removeEvent(document, "mousemove", e), o.drawAnnotation) { var a = o.annotations.selected, i = o.exportSVGElements, s = i.length, l = i[s - 2]; i[s - 4]; o.annotations.options.buttons[a].annotationEvents.stop.call(o.drawAnnotation, n), o.annotations.buttons[a][0].setState(0), o["cache-annotations-menu"] && o.setStateCB.call(l, 0), o.annotations.allowZoom = !0, $($("#" + o.renderTo.id)[0].parentNode).find("#divSlope").remove() } o.drawAnnotation = null } t.addEvent(o.container, "mousedown", n), t.addEvent(document, "mouseup", a) } function d(t) { var o = t.annotations.options.buttons; t.annotations.buttons = t.annotations.buttons || [], A(o, function (o, n) { t.annotations.buttons.push(c(t, o, n)) }) } function c(t, o, n) { var e = t.annotations.options.buttonsOffsets, a = t.rangeSelector ? t.rangeSelector.inputGroup.offset : 0, i = t.renderer, s = o.symbol, l = 30, r = s.size, p = o.size, d = t.plotWidth + t.plotLeft - (n + 1) * l - a - e[0], c = t.plotTop - (t.rangeSelector ? 23 + p : 0) + e[1], h = o.events && o.events.click ? o.events.click : u(n, t), x = o.states.selected, f = o.states.hover, o = i.button("", d, c, h, {}, f, x).attr({ width: p, height: p, zIndex: 10, visibility: "hidden" }), v = i.symbol(s.shape, p - r / 2, p - r / 2, r, r).attr(s.style).add(o); return o.attr(o.style).add(), [o, v] } function u(t, o) { return function () { self = o.annotations.buttons[t][0], 2 == self.state ? (o.annotations.selected = -1, o.annotations.allowZoom = !0, self.setState(0)) : (o.annotations.selected >= 0 && o.annotations.buttons[o.annotations.selected][0].setState(0), o.annotations.allowZoom = !1, o.annotations.selected = t, self.setState(2)) } } function h(t, o, n, e) { var a = (o - e) / (t - n); return t !== n ? { a: a, b: e - a * n } : { a: 0, b: 0 } } function x(t) { var o = t.chart, n = o.yAxis[0], e = o.xAxis[0], a = t.options, i = (a.shape.params.d, h(a.xValue, a.yValue, a.xValueEnd, a.yValueEnd)), s = [[a.xValue, a.yValue], [a.xValueEnd, a.yValueEnd]], l = [e.min, e.max], r = [n.min, n.max]; return e.isLog && (l = l.map(function (t) { return e.lin2val(t) })), n.isLog && (r = r.map(function (t) { return n.lin2val(t) })), s[0][0] < l[0] ? (s[0][0] = l[0], s[0][1] = i.a * s[0][0] + i.b) : s[0][0] > l[1] && (s[0][0] = l[1], s[0][1] = i.a * s[0][0] + i.b), s[1][0] < l[0] ? (s[1][0] = l[0], s[1][1] = i.a * s[1][0] + i.b) : s[1][0] > l[1] && (s[1][0] = l[1], s[1][1] = i.a * s[1][0] + i.b), s[0][1] < r[0] ? (s[0][1] = r[0], s[0][0] = (s[0][1] - i.b) / i.a) : s[0][1] > r[1] && (s[0][1] = r[1], s[0][0] = (s[0][1] - i.b) / i.a), s[1][1] < r[0] ? (s[1][1] = r[0], s[1][0] = (s[1][1] - i.b) / i.a) : s[1][1] > r[1] && (s[1][1] = r[1], s[1][0] = (s[1][1] - i.b) / i.a), s } var f, v, y = t, g = y.Chart, b = y.extend, m = y.merge, A = y.each, P = y.pick; y.ALLOWED_SHAPES = ["path", "rect", "circle"], v = { top: 0, left: 0, center: .5, middle: .5, bottom: 1, right: 1 }, y.SVGRenderer.prototype.symbols.line = function (t, o, n, e) { var a = 2; return ["M", t + a, o + a, "L", t + n - a, o + e - a] }, y.VMLRenderer && (y.VMLRenderer.prototype.symbols.line = y.SVGRenderer.prototype.symbols.line), y.SVGRenderer.prototype.symbols.text = function (t, o, n, e) { var a = 1; return ["M", t, o + a, "L", t + n, o + a, "M", t + n / 2, o + a, "L", t + n / 2, o + a + e] }, y.VMLRenderer && (y.VMLRenderer.prototype.symbols.text = y.SVGRenderer.prototype.symbols.text), y.wrap(y.Pointer.prototype, "drag", function (t, o) { this.chart.annotations && !this.chart.annotations.allowZoom || t.call(this, o) }), y.wrap(y.Pointer.prototype, "onContainerMouseDown", function (t, o) { var n = $(o.target); t.call(this, o), !this.chart.selectedAnnotation || n.hasClass("hc-editbox") || n.parents(".hc-editbox").length || this.chart.selectedAnnotation.events.deselect.call(this.chart.selectedAnnotation, o) }); var E = t.inArray, B = y.addEvent, w = !!y.VMLRenderer, V = { getRadius: function (t) { var o = this, n = o.chart, e = n.container.getBoundingClientRect(), a = t.clientX - e.left, i = t.clientY - e.top, s = n.xAxis[o.options.xAxis], l = n.yAxis[o.options.yAxis], r = Math.abs(a - s.toPixels(o.options.xValue)), p = Math.abs(i - l.toPixels(o.options.yValue)); return radius = parseInt(Math.sqrt(r * r + p * p), 10), o.shape.attr({ r: radius }), radius }, getRadiusAndUpdate: function (t) { var o = V.getRadius.call(this, t); this.update({ shape: { params: { r: o, x: -o, y: -o } } }) }, getPath: function (t) { var o = [], n = this, e = n.chart, a = e.container.getBoundingClientRect(), i = t.clientX - a.left, s = t.clientY - a.top, l = (n.chart.options.chart.plotType, e.xAxis[n.options.xAxis]), r = e.yAxis[n.options.yAxis], p = i - l.toPixels(n.options.xValue), d = s - r.toPixels(n.options.yValue); return o = ["M", 0, 0, "L", parseInt(p, 10), parseInt(d, 10)], n.shape.attr({ d: o }), n.options.shape.params.d = o, n.renderRotateAndTranslatePoints(), o }, getPathAndUpdate: function (t) { var o = this, n = o.chart, e = V.getPath.call(o, t), a = n.xAxis[o.options.xAxis], i = n.yAxis[o.options.yAxis], s = (o.chart.options.chart.plotType, a.toValue(e[4] + a.toPixels(o.options.xValue))), l = i.toValue(e[5] + i.toPixels(o.options.yValue)); this.update({ xValueEnd: s, yValueEnd: l, shape: { params: { d: e } } }) }, getRect: function (t) { var o = this, n = o.chart, e = n.container.getBoundingClientRect(), a = t.clientX - e.left, i = t.clientY - e.top, s = n.xAxis[o.options.xAxis], l = n.yAxis[o.options.yAxis], r = s.toPixels(o.options.xValue), p = l.toPixels(o.options.yValue), d = a - r, c = i - p, u = Math.round(d) + 1, h = Math.round(c) + 1, x = {}; return x.x = 0 > u ? u : 0, x.width = Math.abs(u), x.y = 0 > h ? h : 0, x.height = Math.abs(h), o.shape.attr({ x: x.x, y: x.y, width: x.width, height: x.height }), x }, getRectAndUpdate: function (t) { var o = V.getRect.call(this, t); this.update({ shape: { params: o } }) }, getText: function () { }, showInput: function (t) { var o, n = this, e = n.chart, a = e.annotationInputIndex = e.annotationInputIndex ? e.annotationInputIndex : 1, i = document.createElement("span"); e.mouseDownY > 70 && (i.innerHTML = '<input type="text" style="z-index: 999999" class="annotation-' + a + '" placeholder="Add text"><button class=""> Done </button>', i.style.position = "absolute", i.style.left = t.pageX + "px", i.style.top = t.pageY + "px", i.style.zIndex = "1050", document.body.appendChild(i), i.querySelectorAll("input")[0].focus(), o = i.querySelectorAll("button")[0], o.onclick = function () { var t = this.parentNode; n.update({ title: { style: { "font-weight": "normal", "font-style": "normal", "font-size": "12px", color: "#000000" }, y: 12, text: t.querySelectorAll("input")[0].value } }), t.parentNode.removeChild(t) }, e.annotationInputIndex++) } }, M = function () { this.init.apply(this, arguments) }; M.prototype = { init: function (t, n) { var e = n.shape && n.shape.type; this.chart = t, this.options = m({}, o(e), n) }, render: function (o) { function n(o, n) { if (i(n)) for (var a in n) !function (a) { t.addEvent(o.element, a, function (t) { n[a].call(e, t) }) }(a) } var e = this, a = this.chart, s = e.chart.renderer, l = e.group, r = e.title, p = e.shape, d = e.options, c = d.title, u = d.shape, h = d.allowDragX, x = d.allowDragY, f = (a.xAxis[d.xAxis], a.yAxis[d.yAxis], e.hasEvents); l || (l = e.group = s.g(), l.attr({ "class": "highcharts-annotation" })), !p && u && -1 !== E(u.type, t.ALLOWED_SHAPES) && (delete u.params.cursor, p = e.shape = s[d.shape.type](u.params), p.add(l)), !r && c && (r = e.title = s.text(c), r.add(l)), !h && !x || f ? f || ($(l.element).on("mousedown", function (t) { e.events.select(t, e) }), n(l, d.events)) : ($(l.element).on("mousedown", function (t) { e.events.storeAnnotation(t, e, a), e.events.select(t, e) }), B(document, "mouseup", function (t) { e.events.releaseAnnotation(t, a) }), n(l, d.events)), this.hasEvents = !0, l.add(a.annotations.groups[d.yAxis]), e.linkObjects(), e.renderRotateAndTranslatePoints(), o !== !1 && e.redraw() }, redraw: function (o) { var n, e, l, r, p, d, c, u = this.options, h = this.chart, f = this.group, y = this.title, g = this.shape, m = this.linkedObject, A = h.xAxis[u.xAxis], P = h.yAxis[u.yAxis], E = u.width, B = u.height, V = v[u.anchorY], $ = v[u.anchorX], M = !1; h.options.chart.plotType; if (m && (e = m instanceof t.Point ? "point" : m instanceof t.Series ? "series" : null, "point" === e ? (u.xValue = m.x, u.yValue = m.y, l = m.series) : "series" === e && (l = m), f.visibility !== l.group.visibility && f.attr({ visibility: l.group.visibility })), p = i(u.xValue) ? A.toPixels(u.xValue) : u.x, d = i(u.yValue) ? P.toPixels(u.yValue) : u.y, !isNaN(p) && !isNaN(d) && a(p) && a(d)) { if (y) { var T = u.title, C = T.style; delete T.style, w ? y.attr({ text: T.text }) : y.attr(T), u.title.style = C, y.css(C), M = !0 } g && (n = b({}, u.shape.params), "values" === u.shape.units && (i(n.x) && n.width ? (n.width = A.toPixels(n.width + n.x) - A.toPixels(n.x), n.x = A.toPixels(n.x)) : n.width ? n.width = A.toPixels(n.width) - A.toPixels(0) : i(n.x) && (n.x = A.toPixels(n.x)), i(n.y) && n.height ? (n.height = -P.toPixels(n.height + n.y) + P.toPixels(n.y), n.y = P.toPixels(n.y)) : n.height ? n.height = -P.toPixels(n.height) + P.toPixels(0) : i(n.y) && (n.y = P.toPixels(n.y)), "path" === u.shape.type && (n.d = s(n.d, A, P, p, d))), i(u.yValueEnd) && i(u.xValueEnd) && (n.d = n.d || u.shape.d || ["M", 0, 0, "L", 0, 0], c = x(this), p = A.toPixels(c[0][0]), d = P.toPixels(c[0][1]), n.d[4] = A.toPixels(c[1][0]) - p, n.d[5] = P.toPixels(c[1][1]) - d, u.xValue = c[0][0], u.yValue = c[0][1], u.xValueEnd = c[1][0], u.yValueEnd = c[1][1]), "circle" === u.shape.type && (n.x += n.r, n.y += n.r), M = !0, g.attr(n)), f.bBox = null, a(E) || (r = f.getBBox(), E = r.width), a(B) || (r || (r = f.getBBox()), B = r.height), a($) || ($ = v.center), a(V) || (V = v.center), p -= E * $, d -= B * V, this.selectionMarker && this.events.select({}, this), this.renderRotateAndTranslatePoints(), o && h.animation && i(f.translateX) && i(f.translateY) ? f.animate({ translateX: p, translateY: d }) : f.translate(p, d) } }, destroy: function () { var t = this, o = this.chart, n = o.annotations.allItems, e = n.indexOf(t); t.hideEditBox(), o.activeAnnotation = null, e > -1 && (n.splice(e, 1), o.options.annotations.splice(e, 1)), A(["title", "shape", "group"], function (o) { t[o] && t[o].destroy ? (t[o].destroy(), t[o] = null) : t[o] && (t[o].remove(), t[o] = null) }), t.rotatePoints && A(t.rotatePoints, function (t) { t.destroy() }), t.group = t.title = t.shape = t.chart = t.options = t.hasEvents = null }, update: function (t, o) { var n = this, e = this.chart, a = e.annotations.allItems, i = a.indexOf(n), s = m(this.options, t); i >= 0 && (e.options.annotations[i] = s), this.options = s, this.linkObjects(), this.render(o) }, linkObjects: function () { var t = this, o = t.chart, n = t.linkedObject, e = n && (n.id || n.options.id), a = t.options, s = a.linkedTo; i(s) ? i(n) && s === e || (t.linkedObject = o.get(s)) : t.linkedObject = null }, renderRotateAndTranslatePoints: function () { var t = this, o = t.chart, n = t.options, e = o.options.chart.forExport, a = 6, i = e ? {} : { cursor: rotateCursor }, s = { fill: "yellow", stroke: "black", "stroke-width": "1px" }; "path" === n.shape.type && (t.rotatePoints ? A(t.rotatePoints, function (t) { t.destroy() }) : t.rotatePoints = [], t.rotatePoints[0] = o.renderer.rect(-a / 2 + 1, -a / 2 - 1, a, a, 0, 1).attr(s).css(i).add(t.group), t.rotatePoints[1] = o.renderer.rect(Math.round(n.shape.params.d[4] - a / 2) - 4, Math.round(n.shape.params.d[5] - a / 2) - 1, a, a, 0, 1).attr(s).css(i).add(t.group), t.rotatePoints[2] = o.renderer.rect(Math.round((n.shape.params.d[4] - a) / 2), Math.round((n.shape.params.d[5] - a) / 2), a, a, 0, 1).attr(s).css(i).add(t.group), t.rotatePoints[0].on("mousedown", function () { t.rotate = !0, t.rotateEnd = !1, $("body").css({ cursor: rotateCursor }) }), t.rotatePoints[1].on("mousedown", function () { t.rotate = !0, t.rotateEnd = !0, $("body").css({ cursor: rotateCursor }) }), t.rotatePoints[2].on("mousedown", function () { $("body").css({ cursor: selectCursor }) })) }, events: { select: function (t, o, n, e) { var a, i = o.chart, s = i.selectedAnnotation, l = 10; (s && s.selectionMarker && s !== o || e) && (s.hideEditBox(), s.selectionMarker.destroy(), s.selectionMarker = !1), o.selectionMarker || (a = o.group.getBBox(), o.selectionMarker = i.renderer.rect(a.x - l / 2, a.y - l / 2, a.width + l, a.height + l).attr({ "stroke-width": 4, stroke: "transparent", fill: "transparent", dashstyle: "ShortDash", "shape-rendering": "crispEdges" }), o.selectionMarker.add(o.group)), i.selectedAnnotation = o }, deselect: function () { this.selectionMarker && this.group && (this.selectionMarker.destroy(), this.selectionMarker = !1, this.group.bBox = null), this.hideEditBox() }, destroyAnnotation: function (t, o) { o.destroy() }, translateAnnotation: function (t, o) { if (t.stopPropagation(), t.preventDefault(), o.activeAnnotation) { var n, e, a, i, s = (o.container, o.activeAnnotation), l = o.container.getBoundingClientRect(), r = t.clientX - l.left, p = t.clientY - l.top; if (o.isInsidePlot(r - o.plotLeft, p - o.plotTop)) if (o.annotations.allowZoom) { if (s.rotate) { n = s.chart.xAxis[0].toValue(r), e = s.chart.yAxis[0].toValue(p); var d = !0; if (s.rotateEnd ? (a = s.options.xValue, i = s.options.yValue, s.update({ xValueEnd: n, yValueEnd: e })) : (a = s.options.xValueEnd, i = s.options.yValueEnd, void 0 != s.options.isFixedAnnotation && s.options.isFixedAnnotation ? d = !1 : s.update({ xValue: n, yValue: e })), s.events.select(t, s, !1, !0), s.options.slope = (e - i) / (n - a), s.options.intercept = e - (e - i) / (n - a) * n, s.options.X1 = a, s.options.X2 = n, s.options.Y1 = i, s.options.Y2 = e, "WellMBE" == s.options.plotType && d) { i.toFixed(0) <= o.yAxis[0].min && n.toFixed(0) <= o.xAxis[0].min || e.toFixed(0) <= o.yAxis[0].min && a.toFixed(0) <= o.xAxis[0].min ? ($("#txtSlope").val(((e - i) / (n - a)).toExponential(4)), $("#txtIntercept").val((e - (e - i) / (n - a) * n).toExponential(4))) : ($("#txtSlope").val(((e - i) / (n - a)).toExponential(4)), $("#txtIntercept").val((e - (e - i) / (n - a) * n).toExponential(4))), CalculateOGIPAndEUR(s.options.intercept, s.options.slope) } else if ("WellMBEGasPSS" == s.options.plotType) { $("#txtGasPssSlope").val(((e - i) / (n - a)).toExponential(4)), $("#txtGasPssIntercept").val((e - (e - i) / (n - a) * n).toExponential(4)); var c = -(e - (e - i) / (n - a) * n).toExponential(4) / ((e - i) / (n - a)).toExponential(4); $("#txtGasPssCalculatedOGIP").val(c), $("#txtGasPssEUR").val($("#txtGasPssRf").val() * $("#txtGasPssCalculatedOGIP").val() / 100) } else if ("WellMBE-Oil" == s.options.plotType) $("#txtOilPssN").val(Math.abs(-((e - (e - i) / (n - a) * n) / ((e - i) / (n - a))))), $("#txtOilPssEUR").val($("#txtOilPssN").val() * $("#txtOilPssRf").val() / 100); else if ("Palacio and Blasimgame - Gas" == s.options.plotType) { $("#txtGasPandBSlope").val(((e - i) / (n - a)).toExponential(4)), $("#txtGasPandBIntercept").val((e - (e - i) / (n - a) * n).toExponential(4)); var c = CalculateGaForAnnotation((e - (e - i) / (n - a) * n).toExponential(4), ((e - i) / (n - a)).toExponential(4)); $("#txtGasPandBCalculatedOGIP").val(c), $("#txtGasPandBEUR").val($("#txtGasPandBRf").val() * $("#txtGasPandBCalculatedOGIP").val() / 100) } else if ("Palacio and Blasimgame - Oil" == s.options.plotType) { var u = Math.abs((e - i) / (n - a)); CalculateOGIPAndEUR_PandB(0, u) } else if ("Condensate Palacio and Blasimgame - Gas" == s.options.plotType) { $("#txtGasPandBSlope").val(((e - i) / (n - a)).toExponential(4)), $("#txtGasPandBIntercept").val((e - (e - i) / (n - a) * n).toExponential(4)); var c = CalculateGaForAnnotation((e - (e - i) / (n - a) * n).toExponential(4), ((e - i) / (n - a)).toExponential(4)); $("#txtGasPandBCalculatedOGIP").val(c), $("#txtGasPandBEUR").val($("#txtGasPandBRf").val() * $("#txtGasPandBCalculatedOGIP").val() / 100) } else if ("IsCondensate" == s.options.plotType) { var h = parseFloat((e - i) / (n - a)), x = parseFloat(e - (e - i) / (n - a) * n); CalculateGforCondensate(h, x) } else if ("PsuedoTime" == s.options.plotType) { var h = parseFloat((e - i) / (n - a)), x = parseFloat(e - (e - i) / (n - a) * n); CalculateGforPsuedoTime(h, x) } else if ("RESMBE" == s.options.plotType) var h = parseFloat((e - i) / (n - a)), x = parseFloat(e - (e - i) / (n - a) * n); else void 0 != o.options.chart.plotType ? $("#" + o.options.chart.plotType + "_Slope").val(((e - i) / (n - a)).toExponential(2)) : $("#" + o.options.annotations[0].plotType + "_Slope").val(((e - i) / (n - a)).toExponential(2)), void 0 != o.options.chart.plotType ? $("#" + o.options.chart.plotType + "_Intercept").val((e - (e - i) / (n - a) * n).toExponential(2)) : $("#" + o.options.annotations[0].plotType + "_Intercept").val((e - (e - i) / (n - a) * n).toExponential(2)), void 0 != o.options.chart.plotType && $("#" + o.options.chart.plotType + " div.resultData .margin_top5").each(function (t, o) { var n = $(o)[0].childNodes[0].innerHTML; "Slope" == n ? ($(o)[0].childNodes[1].childNodes[0].style.borderColor = "RED", $(o)[0].childNodes[1].childNodes[0].style.borderWidth = "1px") : "Intercept" == n ? ($(o)[0].childNodes[1].childNodes[0].style.borderColor = "RED", $(o)[0].childNodes[1].childNodes[0].style.borderWidth = "1px") : $(o)[0].childNodes[1].childNodes[0].value = "" }) } } else n = s.options.allowDragX ? t.clientX - s.startX + s.group.translateX : s.group.translateX, e = s.options.allowDragY ? t.clientY - s.startY + s.group.translateY : s.group.translateY, s.transX = n, s.transY = e, s.group.attr({ transform: "translate(" + n + "," + e + ")" }), s.hadMove = !0, s.reflowEditBox(t) } }, storeAnnotation: function (t, o, n) { if (n.annotationDraging || (t.stopPropagation(), t.preventDefault()), !w && 0 === t.button || w && 1 === t.button) { var e = t.clientX, a = t.clientY; n.activeAnnotation = o, n.activeAnnotation.startX = e, n.activeAnnotation.startY = a, n.activeAnnotation.transX = 0, n.activeAnnotation.transY = 0, n.annotations.allowZoom = P(o.rotate, !1), n.annotations.eventsReady || (B(document, "mousemove", function (t) { o.events.translateAnnotation(t, n) }), n.annotations.eventsReady = !0), o.options.title && i(o.options.title.text) && o.showEditBox(t) } }, releaseAnnotation: function (t, o) { if (t.stopPropagation(), t.preventDefault(), o.activeAnnotation && (0 !== o.activeAnnotation.transX || 0 !== o.activeAnnotation.transY)) { var n = o.activeAnnotation, e = n.transX, a = n.transY, s = n.options, l = s.xValue, r = s.yValue, p = s.xValueEnd, d = s.yValueEnd, c = s.allowDragX, u = s.allowDragY, h = n.chart.xAxis[n.options.xAxis], x = n.chart.yAxis[n.options.yAxis], f = h.toValue(e), v = x.toValue(a), y = h.toValue(h.toPixels(p) - h.toPixels(l) + e), g = x.toValue(x.toPixels(d) - x.toPixels(r) + a); 0 === e && 0 === a || (c && u ? n.update({ xValue: i(l) ? f : null, yValue: i(r) ? v : null, xValueEnd: i(p) ? y : null, yValueEnd: i(d) ? g : null, x: i(l) ? null : e, y: i(r) ? null : a, title: s.title }, !1) : c ? n.update({ xValue: i(l) ? f : null, yValue: i(r) ? r : null, xValueEnd: i(p) ? y : null, yValueEnd: i(d) ? d : null, x: i(l) ? null : e, y: i(r) ? null : n.options.y, title: s.title }, !1) : u && n.update({ xValue: i(l) ? l : null, yValue: i(r) ? v : null, xValueEnd: i(p) ? p : null, yValueEnd: i(d) ? g : null, x: i(l) ? null : n.options.x, y: i(r) ? null : a, title: s.title }, !1)), n.options.slope = (v - g) / (f - y), n.options.intercept = v - (v - g) / (f - y) * f, $("#" + n.options.plotType + "_Slope").val(n.options.slope.toExponential(2)), $("#" + n.options.plotType + "_Intercept").val(n.options.intercept.toExponential(2)), $("#" + n.options.plotType + " div.resultData .margin_top5").each(function (t, o) { var n = $(o)[0].childNodes[0].innerHTML; "m" == n ? ($(o)[0].childNodes[1].childNodes[0].style.borderColor = "RED", $(o)[0].childNodes[1].childNodes[0].style.borderWidth = "1px") : "c" == n ? ($(o)[0].childNodes[1].childNodes[0].style.borderColor = "RED", $(o)[0].childNodes[1].childNodes[0].style.borderWidth = "1px") : $(o)[0].childNodes[1].childNodes[0].value = "" }), o.activeAnnotation.redraw(), o.activeAnnotation.rotate = !1, o.activeAnnotation = null, o.redraw(!1) } void 0 != o.options && WellMBEPlotArray.length > 0 && $.each(WellMBEPlotArray, function (t, n) { o.renderTo.id == n.div && void 0 != n.plotobj && (n.plotobj.annotations[0].xValue = o.options.annotations[0].xValue, n.plotobj.annotations[0].xValueEnd = o.options.annotations[0].xValueEnd, n.plotobj.annotations[0].yValue = o.options.annotations[0].yValue, n.plotobj.annotations[0].yValueEnd = o.options.annotations[0].yValueEnd) }), !o.activeAnnotation || 0 != o.activeAnnotation.transX && 0 != o.activeAnnotation.transY || void 0 == o.options.annotations || "WellMBEGasPSS" != o.options.annotations[0].plotType && "WellMBE-Oil" != o.options.annotations[0].plotType && "Palacio and Blasimgame - Oil" != o.options.annotations[0].plotType && "Palacio and Blasimgame - Gas" != o.options.annotations[0].plotType && "PsuedoTime" != o.options.annotations[0].plotType ? (o.activeAnnotation && (o.activeAnnotation.rotate = !1), o.activeAnnotation = null) : "WellMBEGasPSS" == o.options.annotations[0].plotType || "WellMBE-Oil" == o.options.annotations[0].plotType ? GetCalculatedDataForFlowingPSS() : "Palacio and Blasimgame - Oil" == o.options.annotations[0].plotType || "Palacio and Blasimgame - Gas" == o.options.annotations[0].plotType ? GetDataForPalacioAndBlasingame() : "PsuedoTime" == o.options.annotations[0].plotType && GetDataForPalacioAndBlasingame(), $("body").css({ cursor: "auto" }), o.annotations && (o.annotations.allowZoom = !0) } }, showEditBox: function (t) { if (this && this.chart) { var o = this, n = o.chart, e = $(n.container).parent(); n.textEditAnnotation = o, n.editBox || (e.append($(editBoxHTML)), n.editBox = e.find(".hc-editbox"), n.editBox.find(".hc-accept").click(function () { n.textEditAnnotation.applyEditBox() }), n.editBox.find(".hc-bold").click(function () { $(this).toggleClass("active") }), n.editBox.find(".hc-italic").click(function () { $(this).toggleClass("active") }), MC.ColorPicker.reload()), o.fillEditBox(), o.reflowEditBox(t), n.editBox.show() } }, reflowEditBox: function () { var t, o, n, e, a, i, s, l, r = this; r && (t = r.chart, t && t.editBox && (n = $(t.container), e = n.offset(), a = r.group.attr("transform").replace("translate(", "").split(","), a && r.title && (i = r.title.getBBox(!0), s = parseFloat(a[0]) - e.left - 4, l = parseFloat(a[1]) + e.top - i.height - 45, o = t.editBox.width(), t.editBox.css({ left: s + o + 15 > window.innerWidth ? window.innerWidth - o - 15 : s, top: l })))) }, hideEditBox: function () { var t, o = this; o && (t = o.chart, t && t.editBox && t.editBox.hide()) }, fillEditBox: function () { if (this && this.chart) { var t = this, o = t.options, n = t.title, e = t.chart, a = e.editBox, i = a.find(".hc-bold"), s = a.find(".hc-italic"), l = $(n.element), r = l.css("font-weight"), p = "italic" === l.css("font-style"); r = "bold" === r || "700" === r, e.editBox.find(".hc-fontsize").val(parseFloat(o.title.style["font-size"])), e.editBox.find(".hc-font-color").val(o.title.style.color), r && !i.hasClass("active") ? i.addClass("active") : r || i.removeClass("active"), p && !s.hasClass("active") ? s.addClass("active") : p || s.removeClass("active"), e.editBox.find(".colorChooser").css("background-color", o.title.style.color) } }, applyEditBox: function () { if (this && this.chart) { var t = this.chart.editBox, o = t.find(".hc-bold").hasClass("active"), n = t.find(".hc-italic").hasClass("active"), e = t.find(".hc-fontsize").val(); this.update({ title: { style: { "font-weight": o ? "bold" : "normal", "font-style": n ? "italic" : "normal", "font-size": e + "px", color: t.find(".hc-font-color").val() }, y: e } }), this.events.select(null, this, !1, !0), this.reflowEditBox() } } }, b(g.prototype, { addAnnotation: function (t, o) { var n, a, i, s, l = this, r = l.annotations.allItems; for (e(t) || (t = [t]), s = t.length, i = 0; s > i; i++)n = new M(l, t[i]), a = r.push(n), a > l.options.annotations.length && l.options.annotations.push(t[i]), n.render(o) }, redrawAnnotations: function () { for (var t = this, o = t.yAxis, n = o.length, e = t.annotations, a = e.options.buttonsOffsets, i = 0; n > i; i++) { var s = o[i], p = e.clipPaths[i]; if (p) p.attr({ x: s.left, y: s.top, width: s.width, height: s.height }); else { var d = r(t, s); e.clipPaths.push(d), e.groups.push(l(t, i, d)) } } A(t.annotations.allItems, function (t) { t.redraw() }), A(t.annotations.buttons, function (o, n) { var e = t.rangeSelector ? t.rangeSelector.inputGroup.offset : 0, i = t.plotWidth + t.plotLeft - 30 * (n + 1) - e - a[0]; o[0].attr({ x: i }) }) } }), g.prototype.callbacks.push(function (o) { for (var a = o.options.annotations, i = o.yAxis, s = i.length, c = [], u = [], h = 0; s > h; h++) { var x = i[h], f = r(o, x); c.push(f), u.push(l(o, h, f)) } o.annotations || (o.annotations = {}), o.annotations.allItems || (o.annotations.allItems = []), o.annotations.allowZoom = !0, o.annotations.chart = o, o.annotations.groups = u, o.annotations.clipPaths = c, e(a) && a.length > 0 && o.addAnnotation(o.options.annotations), o.annotations.options = m(n(), o.options.annotationsOptions ? o.options.annotationsOptions : {}), o.annotations.options.enabledButtons ? (d(o), p(o)) : o.annotations.buttons = [], t.addEvent(o, "redraw", function () { o.redrawAnnotations(), o.editBox && o.textEditAnnotation && o.textEditAnnotation.reflowEditBox() }) }), Array.prototype.indexOf || (Array.prototype.indexOf = function (t) { "use strict"; if (null == this) throw new TypeError; var o = Object(this), n = o.length >>> 0; if (0 === n) return -1; var e = 0; if (arguments.length > 1 && (e = Number(arguments[1]), e != e ? e = 0 : 0 != e && e != 1 / 0 && e != -(1 / 0) && (e = (e > 0 || -1) * Math.floor(Math.abs(e)))), e >= n) return -1; for (var a = e >= 0 ? e : Math.max(n - Math.abs(e), 0); n > a; a++)if (a in o && o[a] === t) return a; return -1 }) }(Highcharts);