"use strict"; !function (e) { "object" == typeof module && module.exports ? module.exports = e : e(Highcharts) }(function (e) { !function (e) { function t() { var e = Array.prototype.slice.call(arguments), t = -Number.MAX_VALUE; return v(e, function (e) { return "undefined" != typeof e && "undefined" != typeof e.length && e.length > 0 ? (t = e.length, !0) : void 0 }), t } function i(e) { var i, o = 0; if (e.series.length > 1) for (var r = 0; r < e.series.length; r++)i = e.series[r], t(i.processedXData, i.options.data, i.points) >= (i.options.boostThreshold || Number.MAX_VALUE) && o++; return o > 5 } function o(e) { return i(e) || e.series.length >= C(e.options.boost && e.options.boost.seriesThreshold, 50) } function r(e) { return o(e.chart) || t(e.processedXData, e.options.data, e.points) >= (e.options.boostThreshold || Number.MAX_VALUE) } function n(e) { function t(t, i) { var o = "vertex" === i ? e.VERTEX_SHADER : e.FRAGMENT_SHADER, r = e.createShader(o); return e.shaderSource(r, t), e.compileShader(r), e.getShaderParameter(r, e.COMPILE_STATUS) ? r : !1 } function i() { function i(t) { return e.getUniformLocation(m, t) } var o = t(S, "vertex"), r = t(R, "fragment"); return o && r ? (m = e.createProgram(), e.attachShader(m, o), e.attachShader(m, r), e.linkProgram(m), e.useProgram(m), e.bindAttribLocation(m, 0, "aVertexPosition"), g = i("uPMatrix"), x = i("pSize"), y = i("fillColor"), A = i("isBubble"), v = i("bubbleSizeAbs"), P = i("bubbleSizeByArea"), E = i("uSampler"), T = i("skipTranslation"), M = i("isCircle"), k = i("isInverted"), !0) : (m = !1, !1) } function o() { e && m && e.deleteProgram(m) } function r() { e.useProgram(m) } function n(t, i) { var o = _[t] = _[t] || e.getUniformLocation(m, t); e.uniform1f(o, i) } function a() { e.uniform1i(E, 0) } function s(t) { e.uniform1i(k, t) } function l(t) { e.uniform1i(M, t ? 1 : 0) } function f() { e.uniform1i(A, 0), e.uniform1i(M, 0) } function u(t, i, o) { var r = t.options, a = Number.MAX_VALUE, s = -Number.MAX_VALUE; "bubble" === t.type && (a = C(r.zMin, Math.min(a, Math.max(i, r.displayNegative === !1 ? r.zThreshold : -Number.MAX_VALUE))), s = C(r.zMax, Math.max(s, o)), e.uniform1i(A, 1), e.uniform1i(M, 1), e.uniform1i(P, "width" !== t.options.sizeBy), e.uniform1i(v, t.options.sizeByAbsoluteValue), n("bubbleZMin", a), n("bubbleZMax", s), n("bubbleZThreshold", t.options.zThreshold), n("bubbleMinSize", t.minPxSize), n("bubbleMaxSize", t.maxPxSize)) } function d(t) { e.uniform4f(y, t[0] / 255, t[1] / 255, t[2] / 255, t[3]) } function c(t) { e.uniform1i(T, t === !0 ? 1 : 0) } function h(t) { e.uniformMatrix4fv(g, !1, t) } function p(t) { e.uniform1f(x, t) } function b() { return m } var m, g, x, y, A, v, P, T, M, k, E, S = ["#version 100", "precision highp float;", "attribute vec4 aVertexPosition;", "attribute vec4 aColor;", "varying highp vec2 position;", "varying highp vec4 vColor;", "uniform mat4 uPMatrix;", "uniform float pSize;", "uniform float translatedThreshold;", "uniform bool hasThreshold;", "uniform bool skipTranslation;", "uniform float xAxisTrans;", "uniform float xAxisMin;", "uniform float xAxisMinPad;", "uniform float xAxisPointRange;", "uniform float xAxisLen;", "uniform bool  xAxisPostTranslate;", "uniform float xAxisOrdinalSlope;", "uniform float xAxisOrdinalOffset;", "uniform float xAxisPos;", "uniform bool  xAxisCVSCoord;", "uniform float yAxisTrans;", "uniform float yAxisMin;", "uniform float yAxisMinPad;", "uniform float yAxisPointRange;", "uniform float yAxisLen;", "uniform bool  yAxisPostTranslate;", "uniform float yAxisOrdinalSlope;", "uniform float yAxisOrdinalOffset;", "uniform float yAxisPos;", "uniform bool  yAxisCVSCoord;", "uniform bool  isBubble;", "uniform bool  bubbleSizeByArea;", "uniform float bubbleZMin;", "uniform float bubbleZMax;", "uniform float bubbleZThreshold;", "uniform float bubbleMinSize;", "uniform float bubbleMaxSize;", "uniform bool  bubbleSizeAbs;", "uniform bool  isInverted;", "float bubbleRadius(){", "float value = aVertexPosition.w;", "float zMax = bubbleZMax;", "float zMin = bubbleZMin;", "float radius = 0.0;", "float pos = 0.0;", "float zRange = zMax - zMin;", "if (bubbleSizeAbs){", "value = value - bubbleZThreshold;", "zMax = max(zMax - bubbleZThreshold, zMin - bubbleZThreshold);", "zMin = 0.0;", "}", "if (value < zMin){", "radius = bubbleZMin / 2.0 - 1.0;", "} else {", "pos = zRange > 0.0 ? (value - zMin) / zRange : 0.5;", "if (bubbleSizeByArea && pos > 0.0){", "pos = sqrt(pos);", "}", "radius = ceil(bubbleMinSize + pos * (bubbleMaxSize - bubbleMinSize)) / 2.0;", "}", "return radius * 2.0;", "}", "float translate(float val,", "float pointPlacement,", "float localA,", "float localMin,", "float minPixelPadding,", "float pointRange,", "float len,", "bool  cvsCoord", "){", "float sign = 1.0;", "float cvsOffset = 0.0;", "if (cvsCoord) {", "sign *= -1.0;", "cvsOffset = len;", "}", "return sign * (val - localMin) * localA + cvsOffset + ", "(sign * minPixelPadding);", "}", "float xToPixels(float value){", "if (skipTranslation){", "return value;// + xAxisPos;", "}", "return translate(value, 0.0, xAxisTrans, xAxisMin, xAxisMinPad, xAxisPointRange, xAxisLen, xAxisCVSCoord);// + xAxisPos;", "}", "float yToPixels(float value, float checkTreshold){", "float v;", "if (skipTranslation){", "v = value;// + yAxisPos;", "} else {", "v = translate(value, 0.0, yAxisTrans, yAxisMin, yAxisMinPad, yAxisPointRange, yAxisLen, yAxisCVSCoord);// + yAxisPos;", "}", "if (checkTreshold > 0.0 && hasThreshold) {", "v = min(v, translatedThreshold);", "}", "return v;", "}", "void main(void) {", "if (isBubble){", "gl_PointSize = bubbleRadius();", "} else {", "gl_PointSize = pSize;", "}", "vColor = aColor;", "if (isInverted) {", "gl_Position = uPMatrix * vec4(xToPixels(aVertexPosition.y) + yAxisPos, yToPixels(aVertexPosition.x, aVertexPosition.z) + xAxisPos, 0.0, 1.0);", "} else {", "gl_Position = uPMatrix * vec4(xToPixels(aVertexPosition.x) + xAxisPos, yToPixels(aVertexPosition.y, aVertexPosition.z) + yAxisPos, 0.0, 1.0);", "}", "}"].join("\n"), R = ["precision highp float;", "uniform vec4 fillColor;", "varying highp vec2 position;", "varying highp vec4 vColor;", "uniform sampler2D uSampler;", "uniform bool isCircle;", "uniform bool hasColor;", "void main(void) {", "vec4 col = fillColor;", "if (hasColor) {", "col = vColor;", "}", "if (isCircle) {", "gl_FragColor = col * texture2D(uSampler, gl_PointCoord.st);", "} else {", "gl_FragColor = col;", "}", "}"].join("\n"), _ = {}; return e && i(), { psUniform: function () { return x }, pUniform: function () { return g }, fillColorUniform: function () { return y }, setBubbleUniforms: u, bind: r, program: b, create: i, setUniform: n, setPMatrix: h, setColor: d, setPointSize: p, setSkipTranslation: c, setTexture: a, setDrawAsCircle: l, reset: f, setInverted: s, destroy: o } } function a(e, t, i) { function o() { u && e.deleteBuffer(u) } function r(i, o, r) { return f = i || [], f && 0 !== f.length || h ? (c = r || c, u && e.deleteBuffer(u), u = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, u), e.bufferData(e.ARRAY_BUFFER, h || new Float32Array(f), e.STATIC_DRAW), d = e.getAttribLocation(t.program(), o), e.enableVertexAttribArray(d), !0) : (u = !1, !1) } function n() { return u ? void e.vertexAttribPointer(d, c, e.FLOAT, !1, 0, 0) : !1 } function a(t, i, o) { var r = h ? h.length : f.length; return u && r ? ((!t || t > r || 0 > t) && (t = 0), (!i || i > r) && (i = r), o = o || "points", e.drawArrays(e[o.toUpperCase()], t / c, (i - t) / c), !0) : !1 } function s(e, t, i, o) { h && (h[++p] = e, h[++p] = t, h[++p] = i, h[++p] = o) } function l(e) { e *= 4, p = -1, h = new Float32Array(e) } var f, u = !1, d = !1, c = i || 2, h = !1, p = 0; return { destroy: o, bind: n, data: f, build: r, render: a, allocate: l, push: s } } function s(t) { function i(e) { S(!0, W, e) } function o(e) { var t, i, o; return r(e) ? (t = !!e.options.stacking, i = e.xData || e.options.xData || e.processedXData, o = (t ? e.data : i || e.options.data).length, "treemap" === e.type ? o *= 12 : "heatmap" === e.type ? o *= 6 : H[e.type] && (o *= 2), o) : 0 } function s(e) { var t = 0; W.usePreallocated && (v(e.series, function (e) { r(e) && (t += o(e)) }), U.allocate(t)) } function l(e) { var t = 0; W.usePreallocated && (r(e) && (t = o(e)), U.allocate(t)) } function f(e, t) { var i = 0, o = 1; return [2 / e, 0, 0, 0, 0, -(2 / t), 0, 0, 0, 0, -2 / (o - i), 0, -1, 1, -(o + i) / (o - i), 1] } function u() { w.clear(w.COLOR_BUFFER_BIT | w.DEPTH_BUFFER_BIT) } function d() { return w } function c(t, i) { function o(e) { e && (i.colorData.push(e[0]), i.colorData.push(e[1]), i.colorData.push(e[2]), i.colorData.push(e[3])) } function r(e, t, i, r, n) { o(n), W.usePreallocated ? U.push(e, t, i ? 1 : 0, r || 1) : (B.push(e), B.push(t), B.push(i ? 1 : 0), B.push(r || 1)) } function n(e, t, i, n, a) { o(a), r(e + i, t), o(a), r(e, t), o(a), r(e, t + n), o(a), r(e, t + n), o(a), r(e + i, t + n), o(a), r(e + i, t) } function a(e) { W.useGPUTranslations || (i.skipTranslation = !0, e.x = S.toPixels(e.x, !0), e.y = E.toPixels(e.y, !0)), r(e.x, e.y, 0, 2) } var s, l, f, u, d = t.pointArrayMap && "low,high" === t.pointArrayMap.join(","), c = t.chart, h = t.options, p = !!h.stacking, b = h.data, m = t.xAxis.getExtremes(), g = m.min, x = m.max, y = t.yAxis.getExtremes(), A = y.min, P = y.max, T = t.xData || h.xData || t.processedXData, M = t.yData || h.yData || t.processedYData, k = t.zData || h.zData || t.processedZData, E = t.yAxis, S = t.xAxis, C = !T || 0 === T.length, R = t.points || !1, _ = !1, D = p ? t.data : T || b, z = { x: Number.MIN_VALUE, y: 0 }, w = { x: Number.MIN_VALUE, y: 0 }; if (!(h.boostData && h.boostData.length > 0)) { if (t.closestPointRangePx = Number.MAX_VALUE, R && R.length > 0) return i.skipTranslation = !0, i.drawMode = "triangles", R[0].node && R[0].node.levelDynamic && R.sort(function (e, t) { if (e.node) { if (e.node.levelDynamic > t.node.levelDynamic) return 1; if (e.node.levelDynamic < t.node.levelDynamic) return -1 } return 0 }), void v(R, function (i) { var o, r, a, s = i.plotY; "undefined" == typeof s || isNaN(s) || null === i.y || (o = i.shapeArgs, a = i.series.pointAttribs(i), r = a["stroke-width"] || 0, f = e.color(a.fill).rgba, f[0] /= 255, f[1] /= 255, f[2] /= 255, "treemap" === t.type && (r = r || 1, u = e.color(a.stroke).rgba, u[0] /= 255, u[1] /= 255, u[2] /= 255, n(o.x, o.y, o.width, o.height, u), r /= 2), "heatmap" === t.type && c.inverted && (o.x = S.len - o.x, o.y = E.len - o.y, o.width = -o.width, o.height = -o.height), n(o.x + r, o.y + r, o.width - 2 * r, o.height - 2 * r, f)) }); v(D, function (e, o) { var n, a, f, u, h = !1, b = !1, m = "undefined" == typeof c.index, y = !1, v = !1, T = !1, R = H[t.type], U = !1, L = !0; return m ? !1 : (C ? (n = e[0], a = e[1], D[o + 1] && (b = D[o + 1][0]), D[o - 1] && (h = D[o - 1][0]), e.length >= 3 && (f = e[2], e[2] > i.zMax && (i.zMax = e[2]), e[2] < i.zMin && (i.zMin = e[2]))) : (n = e, a = M[o], D[o + 1] && (b = D[o + 1]), D[o - 1] && (h = D[o - 1]), k && k.length && (f = k[o], k[o] > i.zMax && (i.zMax = k[o]), k[o] < i.zMin && (i.zMin = k[o]))), b && b >= g && x >= b && (y = !0), h && h >= g && x >= h && (v = !0), d ? (C && (a = e.slice(1, 3)), u = a[0], a = a[1]) : p && (n = e.x, a = e.stackY, u = a - e.y), t.requireSorting || (L = a >= A && P >= a), n > x && w.x < x && (w.x = n, w.y = a), g > n && z.x < g && (z.x = n, z.y = a), void ((0 === a || a && L) && (n >= g && x >= n && (U = !0), (U || y || v) && (W.useGPUTranslations || (i.skipTranslation = !0, n = S.toPixels(n, !0), a = E.toPixels(a, !0)), R && (s = a, l = 0, 0 > a && (l = a, a = 0), W.useGPUTranslations || (l = E.toPixels(l, !0)), r(n, l, 0, 0, T)), i.hasMarkers && _ !== !1 && (t.closestPointRangePx = Math.min(t.closestPointRangePx, Math.abs(n - _))), r(n, a, 0, "bubble" === t.type ? f || 1 : 2, T), _ = n)))) }), _ || (a(z), a(w)) } } function h(e) { G.length > 0 && (G[G.length - 1].to = B.length, G[G.length - 1].hasMarkers && (G[G.length - 1].markerTo = X.length)), W.timeSeriesProcessing && console.time("building " + e.type + " series"), G.push({ from: B.length, markerFrom: X.length, colorData: [], series: e, zMin: Number.MAX_VALUE, zMax: -Number.MAX_VALUE, hasMarkers: e.options.marker ? e.options.marker.enabled !== !1 : !1, showMarksers: !0, drawMode: { area: "lines", arearange: "lines", areaspline: "line_strip", column: "lines", line: "line_strip", scatter: "points", heatmap: "triangles", treemap: "triangles", bubble: "points" }[e.type] || "line_strip" }), c(e, G[G.length - 1]), W.timeSeriesProcessing && console.timeEnd("building " + e.type + " series") } function p() { G = [], V.data = B = [], X = [] } function b(e) { z && (z.setUniform("xAxisTrans", e.transA), z.setUniform("xAxisMin", e.min), z.setUniform("xAxisMinPad", e.minPixelPadding), z.setUniform("xAxisPointRange", e.pointRange), z.setUniform("xAxisLen", e.len), z.setUniform("xAxisPos", e.pos), z.setUniform("xAxisCVSCoord", !e.horiz)) } function g(e) { z && (z.setUniform("yAxisTrans", e.transA), z.setUniform("yAxisMin", e.min), z.setUniform("yAxisMinPad", e.minPixelPadding), z.setUniform("yAxisPointRange", e.pointRange), z.setUniform("yAxisLen", e.len), z.setUniform("yAxisPos", e.pos), z.setUniform("yAxisCVSCoord", !e.horiz)) } function y(e, t) { z.setUniform("hasThreshold", e), z.setUniform("translatedThreshold", t) } function A(i) { return i ? (!i.chartHeight || !i.chartWidth, L = i.chartWidth || 800, N = i.chartHeight || 400, w && L && N ? (W.timeRendering && console.time("gl rendering"), z.bind(), w.viewport(0, 0, L, N), z.setPMatrix(f(L, N)), W.lineWidth > 1 && !e.isMS && w.lineWidth(W.lineWidth), U.build(V.data, "aVertexPosition", 4), U.bind(), O && (w.bindTexture(w.TEXTURE_2D, D), z.setTexture(D)), z.setInverted(i.options.chart ? i.options.chart.inverted : !1), v(G, function (t, i) { var o, r, n = t.series.options, s = n.threshold, l = E(s), f = t.series.yAxis.getThreshold(s), u = f, d = C(n.marker ? n.marker.enabled : null, t.series.xAxis.isRadial ? !0 : null, t.series.closestPointRangePx > 2 * ((n.marker ? n.marker.radius : 10) || 10)), c = t.series.fillOpacity ? new x(t.series.color).setOpacity(C(n.fillOpacity, .85)).get() : t.series.color; U.bind(), n.colorByPoint && (c = t.series.chart.options.colors[i]), r = e.color(c).rgba, W.useAlpha || (r[3] = 1), "add" === n.boostBlending ? (w.blendFunc(w.SRC_ALPHA, w.ONE), w.blendEquation(w.FUNC_ADD)) : "mult" === n.boostBlending ? w.blendFunc(w.DST_COLOR, w.ZERO) : "darken" === n.boostBlending ? (w.blendFunc(w.ONE, w.ONE), w.blendEquation(w.FUNC_MIN)) : w.blendFuncSeparate(w.SRC_ALPHA, w.ONE_MINUS_SRC_ALPHA, w.ONE, w.ONE_MINUS_SRC_ALPHA), z.reset(), t.colorData.length > 0 && (z.setUniform("hasColor", 1), o = a(w, z), o.build(t.colorData, "aColor", 4), o.bind()), z.setColor(r), b(t.series.xAxis), g(t.series.yAxis), y(l, u), "points" === t.drawMode && (n.marker && n.marker.radius ? z.setPointSize(2 * n.marker.radius) : z.setPointSize(1)), z.setSkipTranslation(t.skipTranslation), "bubble" === t.series.type && z.setBubbleUniforms(t.series, t.zMin, t.zMax), z.setDrawAsCircle(Z[t.series.type] && O || !1), U.render(t.from, t.to, t.drawMode), t.hasMarkers && d && (n.marker && n.marker.radius ? z.setPointSize(2 * n.marker.radius) : z.setPointSize(10), z.setDrawAsCircle(!0), U.render(t.from, t.to, "POINTS")) }), U.destroy(), W.timeRendering && console.timeEnd("gl rendering"), p(), void (t && t())) : !1) : !1 } function P(e) { return u(), e.renderer.forExport ? A(e) : void (F ? A(e) : setTimeout(function () { P(e) }, 1)) } function T(e, t) { L === e && t === t || (L = e, N = t, z.bind(), z.setPMatrix(f(L, N))) } function M(e, t) { var i = 0, o = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"]; if (F = !1, !e) return !1; for (W.timeSetup && console.time("gl setup"); i < o.length && !(w = e.getContext(o[i])); i++); if (!w) return !1; t || p(), w.enable(w.BLEND), w.blendFunc(w.SRC_ALPHA, w.ONE_MINUS_SRC_ALPHA), w.disable(w.DEPTH_TEST), w.depthMask(w.FALSE), z = n(w), U = a(w, z), O = !1, D = w.createTexture(), I.width = 512, I.height = 512, q.fillStyle = "#FFF", q.beginPath(), q.arc(256, 256, 256, 0, 2 * Math.PI), q.fill(); try { w.bindTexture(w.TEXTURE_2D, D), w.texImage2D(w.TEXTURE_2D, 0, w.RGBA, w.RGBA, w.UNSIGNED_BYTE, I), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_WRAP_S, w.CLAMP_TO_EDGE), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_WRAP_T, w.CLAMP_TO_EDGE), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MAG_FILTER, w.LINEAR), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MIN_FILTER, w.LINEAR_MIPMAP_LINEAR), w.generateMipmap(w.TEXTURE_2D), w.bindTexture(w.TEXTURE_2D, null), O = !0 } catch (r) { } return F = !0, W.timeSetup && console.timeEnd("gl setup"), !0 } function k() { return w !== !1 } function R() { return F } function _() { U.destroy(), z.destroy(), w && (D && w.deleteTexture(D), w.canvas.width = 1, w.canvas.height = 1) } var D, z = !1, U = !1, w = !1, L = 0, N = 0, B = !1, X = !1, O = !1, V = {}, F = !1, G = [], I = m.createElement("canvas"), q = I.getContext("2d"), H = { column: !0, area: !0 }, Z = { scatter: !0, bubble: !0 }, W = { pointSize: 1, lineWidth: 3, fillColor: "#AA00AA", useAlpha: !0, usePreallocated: !1, useGPUTranslations: !1, timeRendering: !1, timeSeriesProcessing: !1, timeSetup: !1 }; return V = { allocateBufferForSingleSeries: l, pushSeries: h, setSize: T, inited: R, setThreshold: y, init: M, render: P, settings: W, valid: k, clear: u, flush: p, setXAxis: b, setYAxis: g, data: B, gl: d, allocateBuffer: s, destroy: _, setOptions: i } } function l(t, i) { var r = t.chartWidth, n = t.chartHeight, a = t, l = t.seriesGroup || i.group; return a = o(t) ? t : i, a.ogl, a.image || (a.canvas = m.createElement("canvas"), a.image = t.renderer.image("", 0, 0, r, n).add(l), a.boostClipRect = t.renderer.clipRect(t.plotLeft, t.plotTop, t.plotWidth, t.plotHeight), a.image.clip(a.boostClipRect), a instanceof e.Chart && (a.markerGroup = a.renderer.g().add(l), a.markerGroup.translate(i.xAxis.pos, i.yAxis.pos))), a.canvas.width = r, a.canvas.height = n, a.image.attr({ x: 0, y: 0, width: r, height: n, style: "pointer-events: none" }), a.boostClipRect.attr({ x: t.plotLeft, y: t.plotTop, width: t.plotWidth, height: t.plotHeight }), a.ogl || (a.ogl = s(function () { a.image.attr({ href: a.canvas.toDataURL("image/png") }), a.ogl.destroy(), a.ogl = !1 }), a.ogl.init(a.canvas), a.ogl.setOptions(t.options.boost || {}), a instanceof e.Chart && a.ogl.allocateBuffer(t)), a.ogl.setSize(r, n), a.ogl } function f(e, t, i) { e && t.image && t.canvas && !o(i || t.chart) && e.render(i || t.chart) } function u(e, t) { e && t.image && t.canvas && !o(t.chart) && e.allocateBufferForSingleSeries(t) } function d(e, t, i, o, r, n) { r = r || 0, o = o || D; for (var a = r + o, s = !0; s && a > r && r < e.length;)s = t(e[r], r), ++r; s && (r < e.length ? n ? d(e, t, i, o, r, n) : b.requestAnimationFrame ? b.requestAnimationFrame(function () { d(e, t, i, o, r) }) : setTimeout(function () { d(e, t, i, o, r) }) : i && i()) } function c() { var e, t = 0, i = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"], o = !1; if ("undefined" != typeof b.WebGLRenderingContext) for (e = m.createElement("canvas"); t < i.length; t++)try { if (o = e.getContext(i[t]), "undefined" != typeof o && null !== o) return !0 } catch (r) { } return !1 } function h(e) { if (!r(this)) return e.call(this); var t = l(this.chart, this); t && (u(t, this), t.pushSeries(this)), f(t, this) } var p, b = e.win, m = b.document, g = function () { }, x = e.Color, y = e.Series, A = e.seriesTypes, v = e.each, P = e.extend, T = e.addEvent, M = e.fireEvent, k = e.grep, E = e.isNumber, S = e.merge, C = e.pick, R = e.wrap, _ = e.getOptions().plotOptions, D = 5e4; x.prototype.names = { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dodgerblue: "#1e90ff", feldspar: "#d19275", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gray: "#808080", green: "#008000", greenyellow: "#adff2f", honeydew: "#f0fff0", hotpink: "#ff69b4", indianred: "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderblush: "#fff0f5", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgrey: "#d3d3d3", lightgreen: "#90ee90", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslateblue: "#8470ff", lightslategray: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370d8", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#d87093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", violetred: "#d02090", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32" }, y.prototype.getPoint = function (e) { var t = e, i = this.xData || this.options.xData || this.processedXData || !1; return !e || e instanceof this.pointClass || (t = (new this.pointClass).init(this, this.options.data[e.i], i ? i[e.i] : void 0), t.category = t.x, t.dist = e.dist, t.distX = e.distX, t.plotX = e.plotX, t.plotY = e.plotY, t.index = e.i), t }, R(y.prototype, "searchPoint", function (e) { return this.getPoint(e.apply(this, [].slice.call(arguments, 1))) }), R(y.prototype, "destroy", function (e) { var t = this, i = t.chart; i.markerGroup === t.markerGroup && (t.markerGroup = null), i.hoverPoints && (i.hoverPoints = k(i.hoverPoints, function (e) { return e.series === t })), i.hoverPoint && i.hoverPoint.series === t && (i.hoverPoint = null), e.call(this) }), R(y.prototype, "getExtremes", function (e) { return r(this) && this.hasExtremes && this.hasExtremes() ? void 0 : e.apply(this, Array.prototype.slice.call(arguments, 1)) }), v(["area", "arearange", "column", "line", "scatter", "heatmap", "bubble", "treemap", "heatmap"], function (e) { _[e] && (_[e].boostThreshold = 5e3, _[e].boostData = []) }), v(["translate", "generatePoints", "drawTracker", "drawPoints", "render"], function (e) { function t(t) { var i = this.options.stacking && ("translate" === e || "generatePoints" === e); !r(this) || i || "heatmap" === this.type || "treemap" === this.type ? ("render" === e && this.image && !o(this.chart) && (this.image.attr({ href: "" }), this.animate = null), t.call(this)) : this[e + "Canvas"] && this[e + "Canvas"]() } R(y.prototype, e, t), "translate" === e && (A.column && R(A.column.prototype, e, t), A.arearange && R(A.arearange.prototype, e, t), A.treemap && R(A.treemap.prototype, e, t), A.heatmap && R(A.heatmap.prototype, e, t)) }), c() ? (R(y.prototype, "processData", function (e) { r(this) && "heatmap" !== this.type && "treemap" !== this.type || e.apply(this, Array.prototype.slice.call(arguments, 1)), this.hasExtremes && this.hasExtremes(!0) || e.apply(this, Array.prototype.slice.call(arguments, 1)) }), e.extend(y.prototype, { pointRange: 0, directTouch: !1, allowDG: !1, hasExtremes: function (e) { var t = this.options, i = t.data, o = this.xAxis && this.xAxis.options, r = this.yAxis && this.yAxis.options; return i.length > (t.boostThreshold || Number.MAX_VALUE) && E(r.min) && E(r.max) && (!e || E(o.min) && E(o.max)) }, destroyGraphics: function () { var e, t, i = this, o = this.points; if (o) for (t = 0; t < o.length; t += 1)e = o[t], e && e.graphic && (e.graphic = e.graphic.destroy()); v(["graph", "area", "tracker"], function (e) { i[e] && (i[e] = i[e].destroy()) }) }, renderCanvas: function () { function e(e, t) { var o, r, l, f, u, d, h = "undefined" == typeof x.index, p = !0; return h || (V ? (o = e[0], r = e[1]) : (o = e, r = P[t]), N ? (V && (r = e.slice(1, 3)), d = r[0], r = r[1]) : B && (o = e.x, r = e.stackY, d = r - e.y), u = null === r, O || (p = r >= R && _ >= r), !u && o >= E && S >= o && p && (l = Math.ceil(y.toPixels(o, !0)), z ? (void 0 !== s && l !== i || (N || (d = r), (void 0 === c || r > a) && (a = r, c = t), (void 0 === s || n > d) && (n = d, s = t)), l !== i && (void 0 !== s && (f = A.toPixels(a, !0), L = A.toPixels(n, !0), F(l, f, c), L !== f && F(l, L, s)), s = c = void 0, i = l)) : (f = Math.ceil(A.toPixels(r, !0)), F(l, f, t)))), !h } function t() { M(h, "renderedCanvas"), h.directTouch = !1, h.options.stickyTracking = !0, delete h.buildKDTree, h.buildKDTree() } var i, r, n, a, s, c, h = this, b = h.options || {}, m = !1, x = h.chart, y = this.xAxis, A = this.yAxis, v = b.xData || h.processedXData, P = b.yData || h.processedYData, T = b.data, k = y.getExtremes(), E = k.min, S = k.max, C = A.getExtremes(), R = C.min, _ = C.max, D = {}, z = !!h.sampling, U = b.enableMouseTracking !== !1, w = b.threshold, L = A.getThreshold(w), N = h.pointArrayMap && "low,high" === h.pointArrayMap.join(","), B = !!b.stacking, X = h.cropStart || 0, O = h.requireSorting, V = !v, F = function (e, t, i) { p = e + "," + t, U && !D[p] && (D[p] = !0, x.inverted && (e = y.len - e, t = A.len - t), r.push({ clientX: e, plotX: e, plotY: t, i: X + i })) }; return m = l(x, h), this.visible ? ((this.points || this.graph) && this.destroyGraphics(), o(x) ? this.markerGroup = x.markerGroup : this.markerGroup = h.plotGroup("markerGroup", "markers", !0, 1, x.seriesGroup), r = this.points = [], h.buildKDTree = g, m && (u(m, this), m.pushSeries(h), f(m, this, x)), void d(B ? h.data : v || T, e, t, x.renderer.forExport ? Number.MAX_VALUE : void 0)) : void (!o(x) && m && (m.clear(), this.image.attr({ href: "" }))) } }), v(["heatmap", "treemap"], function (e) { A[e] && (R(A[e].prototype, "drawPoints", h), A[e].prototype.directTouch = !1) }), A.bubble && (delete A.bubble.prototype.buildKDTree, A.bubble.prototype.directTouch = !1, R(A.bubble.prototype, "markerAttribs", function (e) { return r(this) ? !1 : e.apply(this, [].slice.call(arguments, 1)) })), A.scatter.prototype.fill = !0, P(A.area.prototype, { fill: !0, fillOpacity: !0, sampling: !0 }), P(A.column.prototype, { fill: !0, sampling: !0 }), R(y.prototype, "setVisible", function (e, t) { e.call(this, t, !1), this.visible === !1 && this.canvas && this.image ? (this.ogl && this.ogl.clear(), this.image.attr({ href: "" })) : this.chart.redraw() }), e.Chart.prototype.callbacks.push(function (e) { function t() { e.ogl && o(e) && e.ogl.render(e) } function i() { !o(e) && e.didBoost && (e.didBoost = !1, e.image && e.image.attr({ href: "" })), e.canvas && e.ogl && o(e) && (e.didBoost = !0, e.ogl.allocateBuffer(e)), e.markerGroup && e.xAxis && e.xAxis.length > 0 && e.yAxis && e.yAxis.length > 0 && e.markerGroup.translate(e.xAxis[0].pos, e.yAxis[0].pos) } T(e, "predraw", i), T(e, "render", t) })) : "undefined" != typeof e.initCanvasBoost ? e.initCanvasBoost() : e.error(26) }(e) });