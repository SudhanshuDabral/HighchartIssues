"use strict"; !function (t) { "object" == typeof module && module.exports ? module.exports = t : t(Highcharts) }(function (t) { !function (t) { function i(t, i, a) { this.init(t, i, a) } var a = t.each, e = t.extend, o = t.merge, n = t.splat; e(i.prototype, { init: function (t, i, e) { var s, r = this, l = r.defaultOptions; r.chart = i, r.options = t = o(l, i.angular ? { background: {} } : void 0, t), s = t.background, s && a([].concat(n(s)).reverse(), function (t) { var i, a = e.userOptions; i = o(r.defaultBackgroundOptions, t), t.backgroundColor && (i.backgroundColor = t.backgroundColor), i.color = i.backgroundColor, e.options.plotBands.unshift(i), a.plotBands = a.plotBands || [], a.plotBands !== e.options.plotBands && a.plotBands.unshift(i) }) }, defaultOptions: { center: ["50%", "50%"], size: "85%", startAngle: 0 }, defaultBackgroundOptions: { className: "highcharts-pane", shape: "circle", borderWidth: 1, borderColor: "#cccccc", backgroundColor: { linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 }, stops: [[0, "#ffffff"], [1, "#e6e6e6"]] }, from: -Number.MAX_VALUE, innerRadius: 0, to: Number.MAX_VALUE, outerRadius: "105%" } }), t.Pane = i }(t), function (t) { var i, a, e = t.Axis, o = t.CenteredSeriesMixin, n = t.each, s = t.extend, r = t.map, l = t.merge, h = t.noop, p = t.Pane, c = t.pick, d = t.pInt, u = t.Tick, g = t.splat, f = t.wrap, m = e.prototype, y = u.prototype; i = { getOffset: h, redraw: function () { this.isDirty = !1 }, render: function () { this.isDirty = !1 }, setScale: h, setCategories: h, setTitle: h }, a = { defaultRadialGaugeOptions: { labels: { align: "center", x: 0, y: null }, minorGridLineWidth: 0, minorTickInterval: "auto", minorTickLength: 10, minorTickPosition: "inside", minorTickWidth: 1, tickLength: 10, tickPosition: "inside", tickWidth: 2, title: { rotation: 0 }, zIndex: 2 }, defaultRadialXOptions: { gridLineWidth: 1, labels: { align: null, distance: 15, x: 0, y: null }, maxPadding: 0, minPadding: 0, showLastLabel: !1, tickLength: 0 }, defaultRadialYOptions: { gridLineInterpolation: "circle", labels: { align: "right", x: -3, y: -2 }, showLastLabel: !1, title: { x: 4, text: null, rotation: 90 } }, setOptions: function (t) { var i = this.options = l(this.defaultOptions, this.defaultRadialOptions, t); i.plotBands || (i.plotBands = []) }, getOffset: function () { m.getOffset.call(this), this.chart.axisOffset[this.side] = 0, this.center = this.pane.center = o.getCenter.call(this.pane) }, getLinePath: function (t, i) { var a, e, o = this.center, n = this.chart, s = c(i, o[2] / 2 - this.offset); return this.isCircular || void 0 !== i ? e = this.chart.renderer.symbols.arc(this.left + o[0], this.top + o[1], s, s, { start: this.startAngleRad, end: this.endAngleRad, open: !0, innerR: 0 }) : (a = this.postTranslate(this.angleRad, s), e = ["M", o[0] + n.plotLeft, o[1] + n.plotTop, "L", a.x, a.y]), e }, setAxisTranslation: function () { m.setAxisTranslation.call(this), this.center && (this.isCircular ? this.transA = (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : this.transA = this.center[2] / 2 / (this.max - this.min || 1), this.isXAxis ? this.minPixelPadding = this.transA * this.minPointOffset : this.minPixelPadding = 0) }, beforeSetTickPositions: function () { this.autoConnect = this.isCircular && void 0 === c(this.userMax, this.options.max) && this.endAngleRad - this.startAngleRad === 2 * Math.PI, this.autoConnect && (this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0) }, setAxisSize: function () { m.setAxisSize.call(this), this.isRadial && (this.center = this.pane.center = o.getCenter.call(this.pane), this.isCircular && (this.sector = this.endAngleRad - this.startAngleRad), this.len = this.width = this.height = this.center[2] * c(this.sector, 1) / 2) }, getPosition: function (t, i) { return this.postTranslate(this.isCircular ? this.translate(t) : this.angleRad, c(this.isCircular ? i : this.translate(t), this.center[2] / 2) - this.offset) }, postTranslate: function (t, i) { var a = this.chart, e = this.center; return t = this.startAngleRad + t, { x: a.plotLeft + e[0] + Math.cos(t) * i, y: a.plotTop + e[1] + Math.sin(t) * i } }, getPlotBandPath: function (t, i, a) { var e, o, n, s, l = this.center, h = this.startAngleRad, p = l[2] / 2, u = [c(a.outerRadius, "100%"), a.innerRadius, c(a.thickness, 10)], g = Math.min(this.offset, 0), f = /%$/, m = this.isCircular; return "polygon" === this.options.gridLineInterpolation ? s = this.getPlotLinePath(t).concat(this.getPlotLinePath(i, !0)) : (t = Math.max(t, this.min), i = Math.min(i, this.max), m || (u[0] = this.translate(t), u[1] = this.translate(i)), u = r(u, function (t) { return f.test(t) && (t = d(t, 10) * p / 100), t }), "circle" !== a.shape && m ? (e = h + this.translate(t), o = h + this.translate(i)) : (e = -Math.PI / 2, o = 1.5 * Math.PI, n = !0), u[0] -= g, u[2] -= g, s = this.chart.renderer.symbols.arc(this.left + l[0], this.top + l[1], u[0], u[0], { start: Math.min(e, o), end: Math.max(e, o), innerR: c(u[1], u[0] - u[2]), open: n })), s }, getPlotLinePath: function (t, i) { var a, e, o, s, r = this, l = r.center, h = r.chart, p = r.getPosition(t); return r.isCircular ? s = ["M", l[0] + h.plotLeft, l[1] + h.plotTop, "L", p.x, p.y] : "circle" === r.options.gridLineInterpolation ? (t = r.translate(t), t && (s = r.getLinePath(0, t))) : (n(h.xAxis, function (t) { t.pane === r.pane && (a = t) }), s = [], t = r.translate(t), o = a.tickPositions, a.autoConnect && (o = o.concat([o[0]])), i && (o = [].concat(o).reverse()), n(o, function (i, o) { e = a.getPosition(i, t), s.push(o ? "L" : "M", e.x, e.y) })), s }, getTitlePosition: function () { var t = this.center, i = this.chart, a = this.options.title; return { x: i.plotLeft + t[0] + (a.x || 0), y: i.plotTop + t[1] - { high: .5, middle: .25, low: 0 }[a.align] * t[2] + (a.y || 0) } } }, f(m, "init", function (t, e, o) { var n, r, h, d, u = this, f = e.angular, m = e.polar, y = o.isX, x = f && y, b = e.options, P = o.pane || 0; f ? (s(this, x ? i : a), n = !y, n && (this.defaultRadialOptions = this.defaultRadialGaugeOptions)) : m && (s(this, a), n = y, this.defaultRadialOptions = y ? this.defaultRadialXOptions : l(this.defaultYAxisOptions, this.defaultRadialYOptions)), f || m ? (this.isRadial = !0, e.inverted = !1, b.chart.zoomType = null) : this.isRadial = !1, t.call(this, e, o), x || !f && !m || (r = this.options, e.panes || (e.panes = []), this.pane = h = e.panes[P] = e.panes[P] || new p(g(b.pane)[P], e, u), d = h.options, this.angleRad = (r.angle || 0) * Math.PI / 180, this.startAngleRad = (d.startAngle - 90) * Math.PI / 180, this.endAngleRad = (c(d.endAngle, d.startAngle + 360) - 90) * Math.PI / 180, this.offset = r.offset || 0, this.isCircular = n) }), f(m, "autoLabelAlign", function (t) { return this.isRadial ? void 0 : t.apply(this, [].slice.call(arguments, 1)) }), f(y, "getPosition", function (t, i, a, e, o) { var n = this.axis; return n.getPosition ? n.getPosition(a) : t.call(this, i, a, e, o) }), f(y, "getLabelPosition", function (t, i, a, e, o, n, s, r, l) { var h, p = this.axis, d = n.y, u = 20, g = n.align, f = (p.translate(this.pos) + p.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360; return p.isRadial ? (h = p.getPosition(this.pos, p.center[2] / 2 + c(n.distance, -25)), "auto" === n.rotation ? e.attr({ rotation: f }) : null === d && (d = p.chart.renderer.fontMetrics(e.styles.fontSize).b - e.getBBox().height / 2), null === g && (p.isCircular ? (this.label.getBBox().width > p.len * p.tickInterval / (p.max - p.min) && (u = 0), g = f > u && 180 - u > f ? "left" : f > 180 + u && 360 - u > f ? "right" : "center") : g = "center", e.attr({ align: g })), h.x += n.x, h.y += d) : h = t.call(this, i, a, e, o, n, s, r, l), h }), f(y, "getMarkPath", function (t, i, a, e, o, n, s) { var r, l, h = this.axis; return h.isRadial ? (r = h.getPosition(this.pos, h.center[2] / 2 + e), l = ["M", i, a, "L", r.x, r.y]) : l = t.call(this, i, a, e, o, n, s), l }) }(t), function (t) { var i = t.each, a = t.noop, e = t.pick, o = t.Series, n = t.seriesType, s = t.seriesTypes; n("arearange", "area", { lineWidth: 1, marker: null, threshold: null, tooltip: { pointFormat: '<span style="color:{series.color}">●</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>' }, trackByArea: !0, dataLabels: { align: null, verticalAlign: null, xLow: 0, xHigh: 0, yLow: 0, yHigh: 0 }, states: { hover: { halo: !1 } } }, { pointArrayMap: ["low", "high"], dataLabelCollections: ["dataLabel", "dataLabelUpper"], toYData: function (t) { return [t.low, t.high] }, pointValKey: "low", deferTranslatePolar: !0, highToXY: function (t) { var i = this.chart, a = this.xAxis.postTranslate(t.rectPlotX, this.yAxis.len - t.plotHigh); t.plotHighX = a.x - i.plotLeft, t.plotHigh = a.y - i.plotTop }, translate: function () { var t = this, a = t.yAxis, e = !!t.modifyValue; s.area.prototype.translate.apply(t), i(t.points, function (i) { var o = i.low, n = i.high, s = i.plotY; null === n || null === o ? i.isNull = !0 : (i.plotLow = s, i.plotHigh = a.translate(e ? t.modifyValue(n, i) : n, 0, 1, 0, 1), e && (i.yBottom = i.plotHigh)) }), this.chart.polar && i(this.points, function (i) { t.highToXY(i) }) }, getGraphPath: function (t) { var i, a, o, n, r, l, h, p = [], c = [], d = s.area.prototype.getGraphPath, u = this.options, g = this.chart.polar && u.connectEnds !== !1, f = u.step; for (t = t || this.points, i = t.length, i = t.length; i--;)a = t[i], a.isNull || g || t[i + 1] && !t[i + 1].isNull || c.push({ plotX: a.plotX, plotY: a.plotY, doCurve: !1 }), o = { polarPlotY: a.polarPlotY, rectPlotX: a.rectPlotX, yBottom: a.yBottom, plotX: e(a.plotHighX, a.plotX), plotY: a.plotHigh, isNull: a.isNull }, c.push(o), p.push(o), a.isNull || g || t[i - 1] && !t[i - 1].isNull || c.push({ plotX: a.plotX, plotY: a.plotY, doCurve: !1 }); return r = d.call(this, t), f && (f === !0 && (f = "left"), u.step = { left: "right", center: "center", right: "left" }[f]), l = d.call(this, p), h = d.call(this, c), u.step = f, n = [].concat(r, l), this.chart.polar || "M" !== h[0] || (h[0] = "L"), this.graphPath = n, this.areaPath = this.areaPath.concat(r, h), n.isArea = !0, n.xMap = r.xMap, this.areaPath.xMap = r.xMap, n }, drawDataLabels: function () { var t, i, a, e = this.data, n = e.length, s = [], r = o.prototype, l = this.options.dataLabels, h = l.align, p = l.verticalAlign, c = l.inside, d = this.chart.inverted; if (l.enabled || this._hasPointLabels) { for (t = n; t--;)i = e[t], i && (a = c ? i.plotHigh < i.plotLow : i.plotHigh > i.plotLow, i.y = i.high, i._plotY = i.plotY, i.plotY = i.plotHigh, s[t] = i.dataLabel, i.dataLabel = i.dataLabelUpper, i.below = a, d ? h || (l.align = a ? "right" : "left") : p || (l.verticalAlign = a ? "top" : "bottom"), l.x = l.xHigh, l.y = l.yHigh); for (r.drawDataLabels && r.drawDataLabels.apply(this, arguments), t = n; t--;)i = e[t], i && (a = c ? i.plotHigh < i.plotLow : i.plotHigh > i.plotLow, i.dataLabelUpper = i.dataLabel, i.dataLabel = s[t], i.y = i.low, i.plotY = i._plotY, i.below = !a, d ? h || (l.align = a ? "left" : "right") : p || (l.verticalAlign = a ? "bottom" : "top"), l.x = l.xLow, l.y = l.yLow); r.drawDataLabels && r.drawDataLabels.apply(this, arguments) } l.align = h, l.verticalAlign = p }, alignDataLabel: function () { s.column.prototype.alignDataLabel.apply(this, arguments) }, setStackedPoints: a, getSymbol: a, drawPoints: a }) }(t), function (t) { var i = t.seriesType, a = t.seriesTypes; i("areasplinerange", "arearange", null, { getPointSpline: a.spline.prototype.getPointSpline }) }(t), function (t) { var i = t.defaultPlotOptions, a = t.each, e = t.merge, o = t.noop, n = t.pick, s = t.seriesType, r = t.seriesTypes, l = r.column.prototype; s("columnrange", "arearange", e(i.column, i.arearange, { lineWidth: 1, pointRange: null }), { translate: function () { var t, i, e = this, o = e.yAxis, s = e.xAxis, r = s.startAngleRad, h = e.chart, p = e.xAxis.isRadial; l.translate.apply(e), a(e.points, function (a) { var l, c, d, u = a.shapeArgs, g = e.options.minPointLength; a.plotHigh = i = o.translate(a.high, 0, 1, 0, 1), a.plotLow = a.plotY, d = i, c = n(a.rectPlotY, a.plotY) - i, Math.abs(c) < g ? (l = g - c, c += l, d -= l / 2) : 0 > c && (c *= -1, d -= c), p ? (t = a.barX + r, a.shapeType = "path", a.shapeArgs = { d: e.polarArc(d + c, d, t, t + a.pointWidth) }) : (u.height = c, u.y = d, a.tooltipPos = h.inverted ? [o.len + o.pos - h.plotLeft - d - c / 2, s.len + s.pos - h.plotTop - u.x - u.width / 2, c] : [s.left - h.plotLeft + u.x + u.width / 2, o.pos - h.plotTop + d + c / 2, c]) }) }, directTouch: !0, trackerGroups: ["group", "dataLabelsGroup"], drawGraph: o, crispCol: l.crispCol, drawPoints: l.drawPoints, drawTracker: l.drawTracker, getColumnMetrics: l.getColumnMetrics, animate: function () { return l.animate.apply(this, arguments) }, polarArc: function () { return l.polarArc.apply(this, arguments) }, pointAttribs: l.pointAttribs }) }(t), function (t) { var i = t.each, a = t.isNumber, e = t.merge, o = t.noop, n = t.pick, s = t.pInt, r = t.Series, l = t.seriesType, h = t.TrackerMixin; l("gauge", "line", { dataLabels: { enabled: !0, defer: !1, y: 15, borderRadius: 3, crop: !1, verticalAlign: "top", zIndex: 2, borderWidth: 1, borderColor: "#cccccc" }, dial: {}, pivot: {}, tooltip: { headerFormat: "" }, showInLegend: !1 }, { angular: !0, directTouch: !0, drawGraph: o, fixedBox: !0, forceDL: !0, noSharedTooltip: !0, trackerGroups: ["group", "dataLabelsGroup"], translate: function () { var t = this, o = t.yAxis, r = t.options, l = o.center; t.generatePoints(), i(t.points, function (t) { var i = e(r.dial, t.dial), h = s(n(i.radius, 80)) * l[2] / 200, p = s(n(i.baseLength, 70)) * h / 100, c = s(n(i.rearLength, 10)) * h / 100, d = i.baseWidth || 3, u = i.topWidth || 1, g = r.overshoot, f = o.startAngleRad + o.translate(t.y, null, null, null, !0); a(g) ? (g = g / 180 * Math.PI, f = Math.max(o.startAngleRad - g, Math.min(o.endAngleRad + g, f))) : r.wrap === !1 && (f = Math.max(o.startAngleRad, Math.min(o.endAngleRad, f))), f = 180 * f / Math.PI, t.shapeType = "path", t.shapeArgs = { d: i.path || ["M", -c, -d / 2, "L", p, -d / 2, h, -u / 2, h, u / 2, p, d / 2, -c, d / 2, "z"], translateX: l[0], translateY: l[1], rotation: f }, t.plotX = l[0], t.plotY = l[1] }) }, drawPoints: function () { var t = this, a = t.yAxis.center, o = t.pivot, s = t.options, r = s.pivot, l = t.chart.renderer; i(t.points, function (i) { var a = i.graphic, o = i.shapeArgs, n = o.d, r = e(s.dial, i.dial); a ? (a.animate(o), o.d = n) : (i.graphic = l[i.shapeType](o).attr({ rotation: o.rotation, zIndex: 1 }).addClass("highcharts-dial").add(t.group), i.graphic.attr({ stroke: r.borderColor || "none", "stroke-width": r.borderWidth || 0, fill: r.backgroundColor || "#000000" })) }), o ? o.animate({ translateX: a[0], translateY: a[1] }) : (t.pivot = l.circle(0, 0, n(r.radius, 5)).attr({ zIndex: 2 }).addClass("highcharts-pivot").translate(a[0], a[1]).add(t.group), t.pivot.attr({ "stroke-width": r.borderWidth || 0, stroke: r.borderColor || "#cccccc", fill: r.backgroundColor || "#000000" })) }, animate: function (t) { var a = this; t || (i(a.points, function (t) { var i = t.graphic; i && (i.attr({ rotation: 180 * a.yAxis.startAngleRad / Math.PI }), i.animate({ rotation: t.shapeArgs.rotation }, a.options.animation)) }), a.animate = null) }, render: function () { this.group = this.plotGroup("group", "series", this.visible ? "visible" : "hidden", this.options.zIndex, this.chart.seriesGroup), r.prototype.render.call(this), this.group.clip(this.chart.clipRect) }, setData: function (t, i) { r.prototype.setData.call(this, t, !1), this.processData(), this.generatePoints(), n(i, !0) && this.chart.redraw() }, drawTracker: h && h.drawTrackerPoint }, { setState: function (t) { this.state = t } }) }(t), function (t) { var i = t.each, a = t.noop, e = t.pick, o = t.seriesType, n = t.seriesTypes; o("boxplot", "column", { threshold: null, tooltip: { pointFormat: '<span style="color:{point.color}">●</span> <b> {series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>' }, whiskerLength: "50%", fillColor: "#ffffff", lineWidth: 1, medianWidth: 2, states: { hover: { brightness: -.3 } }, whiskerWidth: 2 }, { pointArrayMap: ["low", "q1", "median", "q3", "high"], toYData: function (t) { return [t.low, t.q1, t.median, t.q3, t.high] }, pointValKey: "high", pointAttribs: function (t) { var i = this.options, a = t && t.color || this.color; return { fill: t.fillColor || i.fillColor || a, stroke: i.lineColor || a, "stroke-width": i.lineWidth || 0 } }, drawDataLabels: a, translate: function () { var t = this, a = t.yAxis, e = t.pointArrayMap; n.column.prototype.translate.apply(t), i(t.points, function (t) { i(e, function (i) { null !== t[i] && (t[i + "Plot"] = a.translate(t[i], 0, 1, 0, 1)) }) }) }, drawPoints: function () { var t, a, o, n, s, r, l, h, p, c, d, u, g, f = this, m = f.points, y = f.options, x = f.chart, b = x.renderer, P = 0, M = f.doQuartiles !== !1, A = f.options.whiskerLength; i(m, function (i) { var m, x = i.graphic, v = x ? "animate" : "attr", L = i.shapeArgs, w = {}, k = {}, T = {}, C = i.color || f.color; void 0 !== i.plotY && (p = L.width, c = Math.floor(L.x), d = c + p, u = Math.round(p / 2), t = Math.floor(M ? i.q1Plot : i.lowPlot), a = Math.floor(M ? i.q3Plot : i.lowPlot), o = Math.floor(i.highPlot), n = Math.floor(i.lowPlot), x || (i.graphic = x = b.g("point").add(f.group), i.stem = b.path().addClass("highcharts-boxplot-stem").add(x), A && (i.whiskers = b.path().addClass("highcharts-boxplot-whisker").add(x)), M && (i.box = b.path(h).addClass("highcharts-boxplot-box").add(x)), i.medianShape = b.path(r).addClass("highcharts-boxplot-median").add(x), w.stroke = i.stemColor || y.stemColor || C, w["stroke-width"] = e(i.stemWidth, y.stemWidth, y.lineWidth), w.dashstyle = i.stemDashStyle || y.stemDashStyle, i.stem.attr(w), A && (k.stroke = i.whiskerColor || y.whiskerColor || C, k["stroke-width"] = e(i.whiskerWidth, y.whiskerWidth, y.lineWidth), i.whiskers.attr(k)), M && (m = f.pointAttribs(i), i.box.attr(m)), T.stroke = i.medianColor || y.medianColor || C, T["stroke-width"] = e(i.medianWidth, y.medianWidth, y.lineWidth), i.medianShape.attr(T)), l = i.stem.strokeWidth() % 2 / 2, P = c + u + l, i.stem[v]({ d: ["M", P, a, "L", P, o, "M", P, t, "L", P, n] }), M && (l = i.box.strokeWidth() % 2 / 2, t = Math.floor(t) + l, a = Math.floor(a) + l, c += l, d += l, i.box[v]({ d: ["M", c, a, "L", c, t, "L", d, t, "L", d, a, "L", c, a, "z"] })), A && (l = i.whiskers.strokeWidth() % 2 / 2, o += l, n += l, g = /%$/.test(A) ? u * parseFloat(A) / 100 : A / 2, i.whiskers[v]({ d: ["M", P - g, o, "L", P + g, o, "M", P - g, n, "L", P + g, n] })), s = Math.round(i.medianPlot), l = i.medianShape.strokeWidth() % 2 / 2, s += l, i.medianShape[v]({ d: ["M", c, s, "L", d, s] })) }) }, setStackedPoints: a }) }(t), function (t) { var i = t.each, a = t.noop, e = t.seriesType, o = t.seriesTypes; e("errorbar", "boxplot", { color: "#000000", grouping: !1, linkedTo: ":previous", tooltip: { pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>' }, whiskerWidth: null }, { type: "errorbar", pointArrayMap: ["low", "high"], toYData: function (t) { return [t.low, t.high] }, pointValKey: "high", doQuartiles: !1, drawDataLabels: o.arearange ? function () { var t = this.pointValKey; o.arearange.prototype.drawDataLabels.call(this), i(this.data, function (i) { i.y = i[t] }) } : a, getColumnMetrics: function () { return this.linkedParent && this.linkedParent.columnMetrics || o.column.prototype.getColumnMetrics.call(this) } }) }(t), function (t) { var i = t.correctFloat, a = t.isNumber, e = t.noop, o = t.pick, n = t.Point, s = t.Series, r = t.seriesType, l = t.seriesTypes; r("waterfall", "column", { dataLabels: { inside: !0 }, lineWidth: 1, lineColor: "#333333", dashStyle: "dot", borderColor: "#333333", states: { hover: { lineWidthPlus: 0 } } }, { pointValKey: "y", translate: function () { var t, a, e, n, s, r, h, p, c, d, u, g, f, m = this, y = m.options, x = m.yAxis, b = o(y.minPointLength, 5), P = b / 2, M = y.threshold, A = y.stacking; for (l.column.prototype.translate.apply(this), c = d = M, e = m.points, a = 0, t = e.length; t > a; a++)n = e[a], p = this.processedYData[a], s = n.shapeArgs, r = A && x.stacks[(m.negStacks && M > p ? "-" : "") + m.stackKey], g = m.getStackIndicator(g, n.x), u = r ? r[n.x].points[m.index + "," + a + "," + g.index] : [0, p], n.isSum ? n.y = i(p) : n.isIntermediateSum && (n.y = i(p - d)), h = Math.max(c, c + n.y) + u[0], s.y = x.toPixels(h, !0), n.isSum ? (s.y = x.toPixels(u[1], !0), s.height = Math.min(x.toPixels(u[0], !0), x.len) - s.y) : n.isIntermediateSum ? (s.y = x.toPixels(u[1], !0), s.height = Math.min(x.toPixels(d, !0), x.len) - s.y, d = u[1]) : (s.height = p > 0 ? x.toPixels(c, !0) - s.y : x.toPixels(c, !0) - x.toPixels(c - p, !0), c += p), s.height < 0 && (s.y += s.height, s.height *= -1), n.plotY = s.y = Math.round(s.y) - m.borderWidth % 2 / 2, s.height = Math.max(Math.round(s.height), .001), n.yBottom = s.y + s.height, s.height <= b && !n.isNull ? (s.height = b, s.y -= P, n.plotY = s.y, n.y < 0 ? n.minPointLengthOffset = -P : n.minPointLengthOffset = P) : n.minPointLengthOffset = 0, f = n.plotY + (n.negative ? s.height : 0), m.chart.inverted ? n.tooltipPos[0] = x.len - f : n.tooltipPos[1] = f }, processData: function (t) { var a, e, o, n, r, l, h, p = this, c = p.options, d = p.yData, u = p.options.data, g = d.length, f = c.threshold || 0; for (o = e = n = r = f, h = 0; g > h; h++)l = d[h], a = u && u[h] ? u[h] : {}, "sum" === l || a.isSum ? d[h] = i(o) : "intermediateSum" === l || a.isIntermediateSum ? d[h] = i(e) : (o += l, e += l), n = Math.min(o, n), r = Math.max(o, r); s.prototype.processData.call(this, t), p.dataMin = n, p.dataMax = r }, toYData: function (t) { return t.isSum ? 0 === t.x ? null : "sum" : t.isIntermediateSum ? 0 === t.x ? null : "intermediateSum" : t.y }, pointAttribs: function (t, i) { var a, e = this.options.upColor; return e && !t.options.color && (t.color = t.y > 0 ? e : null), a = l.column.prototype.pointAttribs.call(this, t, i), delete a.dashstyle, a }, getGraphPath: function () { return ["M", 0, 0] }, getCrispPath: function () { var t, i, a, e, o = this.data, n = o.length, s = this.graph.strokeWidth() + this.borderWidth, r = Math.round(s) % 2 / 2, l = []; for (a = 1; n > a; a++)i = o[a].shapeArgs, t = o[a - 1].shapeArgs, e = ["M", t.x + t.width, t.y + o[a - 1].minPointLengthOffset + r, "L", i.x, t.y + o[a - 1].minPointLengthOffset + r], o[a - 1].y < 0 && (e[2] += t.height, e[5] += t.height), l = l.concat(e); return l }, drawGraph: function () { s.prototype.drawGraph.call(this), this.graph.attr({ d: this.getCrispPath() }) }, getExtremes: e }, { getClassName: function () { var t = n.prototype.getClassName.call(this); return this.isSum ? t += " highcharts-sum" : this.isIntermediateSum && (t += " highcharts-intermediate-sum"), t }, isValid: function () { return a(this.y, !0) || this.isSum || this.isIntermediateSum } }) }(t), function (t) { var i = t.LegendSymbolMixin, a = t.noop, e = t.Series, o = t.seriesType, n = t.seriesTypes; o("polygon", "scatter", { marker: { enabled: !1, states: { hover: { enabled: !1 } } }, stickyTracking: !1, tooltip: { followPointer: !0, pointFormat: "" }, trackByArea: !0 }, { type: "polygon", getGraphPath: function () { for (var t = e.prototype.getGraphPath.call(this), i = t.length + 1; i--;)(i === t.length || "M" === t[i]) && i > 0 && t.splice(i, 0, "z"); return this.areaPath = t, t }, drawGraph: function () { this.options.fillColor = this.color, n.area.prototype.drawGraph.call(this) }, drawLegendSymbol: i.drawRectangle, drawTracker: e.prototype.drawTracker, setStackedPoints: a }) }(t), function (t) { var i = t.arrayMax, a = t.arrayMin, e = t.Axis, o = t.color, n = t.each, s = t.isNumber, r = t.noop, l = t.pick, h = t.pInt, p = t.Point, c = t.Series, d = t.seriesType, u = t.seriesTypes; d("bubble", "scatter", { dataLabels: { formatter: function () { return this.point.z }, inside: !0, verticalAlign: "middle" }, marker: { lineColor: null, lineWidth: 1, radius: null, states: { hover: { radiusPlus: 0 } }, symbol: "circle" }, minSize: 8, maxSize: "20%", softThreshold: !1, states: { hover: { halo: { size: 5 } } }, tooltip: { pointFormat: "({point.x}, {point.y}), Size: {point.z}" }, turboThreshold: 1e4, zThreshold: 0, zoneAxis: "z" }, { pointArrayMap: ["y", "z"], parallelArrays: ["x", "y", "z"], trackerGroups: ["markerGroup", "dataLabelsGroup"], bubblePadding: !0, zoneAxis: "z", pointAttribs: function (t, i) { var a = this.options.marker, e = l(a.fillOpacity, .5), n = c.prototype.pointAttribs.call(this, t, i); return 1 !== e && (n.fill = o(n.fill).setOpacity(e).get("rgba")), n }, getRadii: function (t, i, a, e) { var o, n, s, r, l, h = this.zData, p = [], c = this.options, d = "width" !== c.sizeBy, u = c.zThreshold, g = i - t; for (n = 0, o = h.length; o > n; n++)r = h[n], c.sizeByAbsoluteValue && null !== r && (r = Math.abs(r - u), i = Math.max(i - u, Math.abs(t - u)), t = 0), null === r ? l = null : t > r ? l = a / 2 - 1 : (s = g > 0 ? (r - t) / g : .5, d && s >= 0 && (s = Math.sqrt(s)), l = Math.ceil(a + s * (e - a)) / 2), p.push(l); this.radii = p }, animate: function (t) { var i = this.options.animation; t || (n(this.points, function (t) { var a, e = t.graphic; e && e.width && (a = { x: e.x, y: e.y, width: e.width, height: e.height }, e.attr({ x: t.plotX, y: t.plotY, width: 1, height: 1 }), e.animate(a, i)) }), this.animate = null) }, translate: function () { var i, a, e, o = this.data, n = this.radii; for (u.scatter.prototype.translate.call(this), i = o.length; i--;)a = o[i], e = n ? n[i] : 0, s(e) && e >= this.minPxSize / 2 ? (a.marker = t.extend(a.marker, { radius: e, width: 2 * e, height: 2 * e }), a.dlBox = { x: a.plotX - e, y: a.plotY - e, width: 2 * e, height: 2 * e }) : a.shapeArgs = a.plotY = a.dlBox = void 0 }, alignDataLabel: u.column.prototype.alignDataLabel, buildKDTree: r, applyZones: r }, { haloPath: function (t) { return p.prototype.haloPath.call(this, 0 === t ? 0 : (this.marker ? this.marker.radius || 0 : 0) + t) }, ttBelow: !1 }), e.prototype.beforePadding = function () { var t = this, e = this.len, o = this.chart, r = 0, p = e, c = this.isXAxis, d = c ? "xData" : "yData", u = this.min, g = {}, f = Math.min(o.plotWidth, o.plotHeight), m = Number.MAX_VALUE, y = -Number.MAX_VALUE, x = this.max - u, b = e / x, P = []; n(this.series, function (e) { var s, r = e.options; !e.bubblePadding || !e.visible && o.options.chart.ignoreHiddenSeries || (t.allowZoomOutside = !0, P.push(e), c && (n(["minSize", "maxSize"], function (t) { var i = r[t], a = /%$/.test(i); i = h(i), g[t] = a ? f * i / 100 : i }), e.minPxSize = g.minSize, e.maxPxSize = Math.max(g.maxSize, g.minSize), s = e.zData, s.length && (m = l(r.zMin, Math.min(m, Math.max(a(s), r.displayNegative === !1 ? r.zThreshold : -Number.MAX_VALUE))), y = l(r.zMax, Math.max(y, i(s)))))) }), n(P, function (i) { var a, e = i[d], o = e.length; if (c && i.getRadii(m, y, i.minPxSize, i.maxPxSize), x > 0) for (; o--;)s(e[o]) && t.dataMin <= e[o] && e[o] <= t.dataMax && (a = i.radii[o], r = Math.min((e[o] - u) * b - a, r), p = Math.max((e[o] - u) * b + a, p)) }), P.length && x > 0 && !this.isLog && (p -= e, b *= (e + r - p) / e, n([["min", "userMin", r], ["max", "userMax", p]], function (i) { void 0 === l(t.options[i[0]], t[i[1]]) && (t[i[0]] += i[2] / b) })) } }(t), function (t) { function i(t, i) { var a, e = this.chart, o = this.options.animation, n = this.group, s = this.markerGroup, r = this.xAxis.center, l = e.plotLeft, h = e.plotTop; e.polar ? e.renderer.isSVG && (o === !0 && (o = {}), i ? (a = { translateX: r[0] + l, translateY: r[1] + h, scaleX: .001, scaleY: .001 }, n.attr(a), s && s.attr(a)) : (a = { translateX: l, translateY: h, scaleX: 1, scaleY: 1 }, n.animate(a, o), s && s.animate(a, o), this.animate = null)) : t.call(this, i) } var a, e = t.each, o = t.pick, n = t.Pointer, s = t.Series, r = t.seriesTypes, l = t.wrap, h = s.prototype, p = n.prototype; h.searchPointByAngle = function (t) { var i = this, a = i.chart, e = i.xAxis, o = e.pane.center, n = t.chartX - o[0] - a.plotLeft, s = t.chartY - o[1] - a.plotTop; return this.searchKDTree({ clientX: 180 + Math.atan2(n, s) * (-180 / Math.PI) }) }, l(h, "buildKDTree", function (t) { this.chart.polar && (this.kdByAngle ? this.searchPoint = this.searchPointByAngle : this.kdDimensions = 2), t.apply(this) }), h.toXY = function (t) { var i, a, e = this.chart, o = t.plotX, n = t.plotY; t.rectPlotX = o, t.rectPlotY = n, i = this.xAxis.postTranslate(t.plotX, this.yAxis.len - n), t.plotX = t.polarPlotX = i.x - e.plotLeft, t.plotY = t.polarPlotY = i.y - e.plotTop, this.kdByAngle ? (a = (o / Math.PI * 180 + this.xAxis.pane.options.startAngle) % 360, 0 > a && (a += 360), t.clientX = a) : t.clientX = t.plotX }, r.spline && l(r.spline.prototype, "getPointSpline", function (t, i, a, e) { var o, n, s, r, l, h, p, c, d, u, g, f, m, y, x, b, P, M, A = 1.5, v = A + 1; return this.chart.polar ? (n = a.plotX, s = a.plotY, r = i[e - 1], l = i[e + 1], this.connectEnds && (r || (r = i[i.length - 2]), l || (l = i[1])), r && l && (h = r.plotX, p = r.plotY, c = l.plotX, d = l.plotY, u = (A * n + h) / v, g = (A * s + p) / v, f = (A * n + c) / v, m = (A * s + d) / v, y = Math.sqrt(Math.pow(u - n, 2) + Math.pow(g - s, 2)), x = Math.sqrt(Math.pow(f - n, 2) + Math.pow(m - s, 2)), b = Math.atan2(g - s, u - n), P = Math.atan2(m - s, f - n), M = Math.PI / 2 + (b + P) / 2, Math.abs(b - M) > Math.PI / 2 && (M -= Math.PI), u = n + Math.cos(M) * y, g = s + Math.sin(M) * y, f = n + Math.cos(Math.PI + M) * x, m = s + Math.sin(Math.PI + M) * x, a.rightContX = f, a.rightContY = m), e ? (o = ["C", r.rightContX || r.plotX, r.rightContY || r.plotY, u || n, g || s, n, s], r.rightContX = r.rightContY = null) : o = ["M", n, s]) : o = t.call(this, i, a, e), o }), l(h, "translate", function (t) { var i, a, e = this.chart; if (t.call(this), e.polar && (this.kdByAngle = e.tooltip && e.tooltip.shared, !this.preventPostTranslate)) for (i = this.points, a = i.length; a--;)this.toXY(i[a]) }), l(h, "getGraphPath", function (t, i) { var a, o, n = this; if (this.chart.polar) { for (i = i || this.points, a = 0; a < i.length; a++)if (!i[a].isNull) { o = a; break } this.options.connectEnds !== !1 && void 0 !== o && (this.connectEnds = !0, i.splice(i.length, 0, i[o])), e(i, function (t) { void 0 === t.polarPlotY && n.toXY(t) }) } return t.apply(this, [].slice.call(arguments, 1)) }), l(h, "animate", i), r.column && (a = r.column.prototype, a.polarArc = function (t, i, a, e) { var n = this.xAxis.center, s = this.yAxis.len; return this.chart.renderer.symbols.arc(n[0], n[1], s - i, null, { start: a, end: e, innerR: s - o(t, s) }) }, l(a, "animate", i), l(a, "translate", function (t) { var i, a, e, o, n = this.xAxis, s = n.startAngleRad; if (this.preventPostTranslate = !0, t.call(this), n.isRadial) for (a = this.points, o = a.length; o--;)e = a[o], i = e.barX + s, e.shapeType = "path", e.shapeArgs = { d: this.polarArc(e.yBottom, e.plotY, i, i + e.pointWidth) }, this.toXY(e), e.tooltipPos = [e.plotX, e.plotY], e.ttBelow = e.plotY > n.center[1] }), l(a, "alignDataLabel", function (t, i, a, e, o, n) { if (this.chart.polar) { var s, r, l = i.rectPlotX / Math.PI * 180; null === e.align && (s = l > 20 && 160 > l ? "left" : l > 200 && 340 > l ? "right" : "center", e.align = s), null === e.verticalAlign && (r = 45 > l || l > 315 ? "bottom" : l > 135 && 225 > l ? "top" : "middle", e.verticalAlign = r), h.alignDataLabel.call(this, i, a, e, o, n) } else t.call(this, i, a, e, o, n) })), l(p, "getCoordinates", function (t, i) { var a = this.chart, o = { xAxis: [], yAxis: [] }; return a.polar ? e(a.axes, function (t) { var e = t.isXAxis, n = t.center, s = i.chartX - n[0] - a.plotLeft, r = i.chartY - n[1] - a.plotTop; o[e ? "xAxis" : "yAxis"].push({ axis: t, value: t.translate(e ? Math.PI - Math.atan2(s, r) : Math.sqrt(Math.pow(s, 2) + Math.pow(r, 2)), !0) }) }) : o = t.call(this, i), o }) }(t) });