!function (e) { function r(e) { var r = [0, 0, 0, 0, 0, 0], t = 0, n = []; for (l = e.length; l > t; t++)e[t].x && (e[t][0] = e[t].x, e[t][1] = e[t].y), e[t][1] && (r[0] += e[t][0], r[1] += e[t][1], r[2] += e[t][0] * e[t][0] * e[t][1], r[3] += e[t][1] * Math.log(e[t][1]), r[4] += e[t][0] * e[t][1] * Math.log(e[t][1]), r[5] += e[t][0] * e[t][1]); for (var o = r[1] * r[2] - r[5] * r[5], a = Math.pow(Math.E, (r[2] * r[3] - r[5] * r[4]) / o), i = (r[1] * r[4] - r[5] * r[3]) / o, s = 0, l = e.length; l > s; s++) { var g = [e[s][0], a * Math.pow(Math.E, i * e[s][0])]; n.push(g) } n.sort(function (e, r) { return e[0] > r[0] ? 1 : e[0] < r[0] ? -1 : 0 }); var h = "y = " + Math.round(100 * a) / 100 + "e^(" + Math.round(100 * i) / 100 + "x)"; return { equation: [a, i], points: n, string: h } } function t(e, r) { for (var t = [0, 0, 0, 0, 0], n = 0, o = [], a = e.length; n < e.length; n++)e[n].x && (e[n][0] = e[n].x, e[n][1] = e[n].y), e[n][1] ? (t[0] += e[n][0], t[1] += e[n][1], t[2] += e[n][0] * e[n][0], t[3] += e[n][0] * e[n][1], t[4] += e[n][1] * e[n][1]) : a -= 1; for (var i = (a * t[3] - t[0] * t[1]) / (a * t[2] - t[0] * t[0]), s = t[1] / a - i * t[0] / a, l = 0, g = e.length; g > l; l++) { var h = e[l][0] * i + s; r && (h = parseFloat(h.toFixed(r))); var u = [e[l][0], h]; o.push(u) } o.sort(function (e, r) { return e[0] > r[0] ? 1 : e[0] < r[0] ? -1 : 0 }); var f = "y = " + Math.round(100 * i) / 100 + "x + " + Math.round(100 * s) / 100; return { equation: [i, s], points: o, string: f } } function n(e) { var r = [0, 0, 0, 0], t = 0, n = []; for (s = e.length; s > t; t++)e[t].x && (e[t][0] = e[t].x, e[t][1] = e[t].y), e[t][1] && (r[0] += Math.log(e[t][0]), r[1] += e[t][1] * Math.log(e[t][0]), r[2] += e[t][1], r[3] += Math.pow(Math.log(e[t][0]), 2)); for (var o = (t * r[1] - r[2] * r[0]) / (t * r[3] - r[0] * r[0]), a = (r[2] - o * r[0]) / t, i = 0, s = e.length; s > i; i++) { var l = [e[i][0], a + o * Math.log(e[i][0])]; n.push(l) } n.sort(function (e, r) { return e[0] > r[0] ? 1 : e[0] < r[0] ? -1 : 0 }); var g = "y = " + Math.round(100 * a) / 100 + " + " + Math.round(100 * o) / 100 + " ln(x)"; return { equation: [o, a], points: n, string: g } } function o(e, r) { "undefined" == typeof r && (r = 2); for (var t = [], n = [], o = [], a = 0, i = 0, l = 0, g = r + 1; g > l; l++) { for (var h = 0, u = e.length; u > h; h++)e[h].x && (e[h][0] = e[h].x, e[h][1] = e[h].y), e[h][1] && (a += Math.pow(e[h][0], l) * e[h][1]); t.push(a), a = 0; for (var f = [], d = 0; g > d; d++) { for (var h = 0, u = e.length; u > h; h++)e[h][1] && (i += Math.pow(e[h][0], l + d)); f.push(i), i = 0 } n.push(f) } n.push(t); for (var p = s(n, g), l = 0, u = e.length; u > l; l++) { for (var c = 0, v = 0; v < p.length; v++)c += p[v] * Math.pow(e[l][0], v); o.push([e[l][0], c]) } o.sort(function (e, r) { return e[0] > r[0] ? 1 : e[0] < r[0] ? -1 : 0 }); for (var S = "y = ", l = p.length - 1; l >= 0; l--)S += l > 1 ? Math.round(100 * p[l]) / 100 + "x^" + l + " + " : 1 == l ? Math.round(100 * p[l]) / 100 + "x + " : Math.round(100 * p[l]) / 100; return { equation: p, points: o, string: S } } function a(e, r) { function t(e) { var r, t = {}, n = e.length, o = []; for (r = 0; n > r; r += 1)t[e[r]] = e[r]; for (r in t) o.push(t[r]); return o } function n(e) { var r = 1 - e * e * e; return r * r * r } var r = r || .25, o = e.map(function (e) { return e[0] }), a = t(o); 2 / a.length > r && (r = Math.min(2 / a.length, 1), console.warn("updated bandwith to " + r)); var i = e.map(function (e) { return e[1] }), s = [], l = 0, g = Math.floor(r * o.length) - 1; for (var h in o) { var u = o[h]; h > 0 && g < o.length - 1 && o[g + 1] - o[h] < o[h] - o[l] && (l++ , g++); var f; f = o[h] - o[l] > o[g] - o[h] ? l : g; for (var d = Math.abs(1 / (o[f] - u)), p = 0, c = 0, v = 0, S = 0, M = 0, m = l; g >= m;) { var y, x = o[m], q = i[m]; y = h > m ? u - x : x - u; var w = n(y * d), b = x * w; p += w, c += b, v += x * b, S += q * w, M += q * b, m++ } var E, P = c / p, k = S / p, Y = M / p, C = v / p; E = C == P * P ? 0 : (Y - P * k) / (C - P * P); var F = k - E * P; s[h] = E * u + F } return console.debug(s), { equation: "", points: o.map(function (e, r) { return [e, s[r]] }), string: "" } } function s(e, r) { var t = 0, n = 0, o = 0, a = 0, i = 0, s = e.length - 1, l = new Array(r); for (t = 0; s > t; t++) { for (a = t, n = t + 1; s > n; n++)Math.abs(e[t][n]) > Math.abs(e[t][a]) && (a = n); for (o = t; s + 1 > o; o++)i = e[o][t], e[o][t] = e[o][a], e[o][a] = i; for (n = t + 1; s > n; n++)for (o = s; o >= t; o--)e[o][n] -= e[o][t] * e[t][n] / e[t][t] } for (n = s - 1; n >= 0; n--) { for (i = 0, o = n + 1; s > o; o++)i += e[o][n] * l[o]; l[n] = (e[s][n] - i) / e[n][n] } return l } function l(e, r) { var t = SSE = SSYY = mean = 0, n = e.length; for (t = 0; t < e.length; t++)e[t][1] ? mean += e[t][1] : n--; for (mean /= n, t = 0; t < e.length; t++)e[t][1] && (SSYY += Math.pow(e[t][1] - r[t][1], 2), SSE += Math.pow(e[t][1] - mean, 2)); return 1 - SSYY / SSE } function g(e, r) { var t = 0, n = e.length; for (i = 0; i < e.length; i++)e[i][1] ? t += Math.pow(e[i][1] - r[i][1], 2) : n--; return t = Math.sqrt(t / (n - 2)) } e.wrap(e.Chart.prototype, "init", function (e) { var i = [], s = arguments[1].series; if (void 0 != s && s.length > 0) { if (void 0 != s[0].regression) { s[0].regressionSettings.color; if (s[0].data.length > 0) if (1 == arguments[1].chart.isWellMBE) { if (GlobalSelectedRegressionPoint.length > 1 && "selection-series-0" == s[1].id) for (var h = 0; h < GlobalSelectedRegressionPoint.length; h++)i.push({ x: GlobalSelectedRegressionPoint[h][0], y: GlobalSelectedRegressionPoint[h][1], marker: { fillColor: null } }) } else for (var h = 0; h < s[0].data.length; h++)null != s[0].data[h].marker.fillColor && i.push({ x: s[0].data[h].x, y: s[0].data[h].y, marker: { fillColor: s[0].data[h].marker.fillColor } }) } if (void 0 != i && i.length > 0) { var u = [], h = 0; for (h = 0; h < s.length; h++) { var f = s[h]; if (f.regression && !f.rendered) { f.regressionSettings = f.regressionSettings || {}, f.regressionSettings.tooltip = f.regressionSettings.tooltip || {}, f.regressionSettings.dashStyle = f.regressionSettings.dashStyle || "solid"; var d, p = f.regressionSettings.type || "linear", c = { data: [], color: f.color, yAxis: f.yAxis, lineWidth: 3, marker: { enabled: !1 }, isRegressionLine: !0, type: f.regressionSettings.linetype || "spline", name: f.regressionSettings.name || "Equation: %eq", color: f.regressionSettings.color || "", dashStyle: f.regressionSettings.dashStyle || "solid", tooltip: { valueSuffix: f.regressionSettings.tooltip.valueSuffix || " " } }; if ("linear" == p) d = t(i, f.regressionSettings.decimalPlaces), c.type = "line"; else if ("exponential" == p) d = r(i); else if ("polynomial" == p) { var v = f.regressionSettings.order || 2; d = o(i, v) } else if ("logarithmic" == p) d = n(i); else { if ("loess" != p) { console.error("Invalid regression type: ", p); break } var S = f.regressionSettings.loessSmooth || 25; d = a(i, S / 100) } d.rSquared = l(i, d.points), d.rValue = Math.sqrt(d.rSquared).toFixed(f.regressionSettings.decimalPlaces), d.rSquared = d.rSquared.toFixed(f.regressionSettings.decimalPlaces), d.standardError = g(i, d.points).toFixed(f.regressionSettings.decimalPlaces), c.data = d.points, c.name = c.name.replace("%r2", d.rSquared), c.name = c.name.replace("%r", d.rValue), c.name = c.name.replace("%eq", d.string), c.name = c.name.replace("%se", d.standardError), c.regressionOutputs = d, u.push(c), arguments[1].series[h].rendered = !0 } } arguments[1].series = s.concat(u) } } e.apply(this, Array.prototype.slice.call(arguments, 1)) }) }(Highcharts);